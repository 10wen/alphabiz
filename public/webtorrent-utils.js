const path = require('path')
const responseTorrentProps = [
  'infoHash', 'name',
  'paused', 'length',
  'downloaded',// 'downloadSpeed',
  'uploaded',// 'uploadSpeed',
  'ready', 'waiting', 'progress',
  'isSeeding', 'upload',
  // the 'token' is generated by client
  'token', 'completed',
  // the 'origin' marks origin magnet link or torrent
  'origin', 'path',
  'pending',
  // seeding file
  'file', 'magnetURI',
  'isAutoUpload',
  // timers
  'createdTime',
  'completedTime',
  'usedTime'
]
/**
 * @typedef { import('../src/types').TorrentInfo } TorrentInfo
 * @typedef { import('webtorrent/lib/torrent') } RawTorrent
 * @typedef { RawTorrent & TorrentInfo } Torrent
 */
/**
 * @method torrentToJson
 * @param { Torrent } tr
 * @param { boolean } isUpload
 * @returns { Partial<Torrent> }
 */
const torrentToJson = (tr, deltaTime, speeder) => {
  const o = {}
  responseTorrentProps.forEach(prop => { o[prop] = tr[prop] })
  o.done = tr.downloaded >= tr.length
  o.download = tr.progress !== 1 && !tr.upload
  o.upload = tr.upload
  // hmm, a typo error that is already used everywhere
  o.recieved = tr.received
  o.files = tr.files
    ? tr.files.map(
      /** @param { import('webtorrent/lib/file') } file */
      file => {
        return {
          name: file.name,
          path: path.resolve(tr.path, file.path),
          progress: file.progress > 0 ? file.progress : 0
        }
      }
    ).filter(i => !i.name.match(/^_____padding_file_(.*)____$/))
    : []
  if (tr.timeRemaining) o.timeRemaining = tr.timeRemaining
  if (tr.metadata) o.hasMetadata = true
  if (tr.numPeers) o.peersNum = tr.numPeers
  o.connections = []
  tr.wires.forEach(wire => {
    // if (!wire.remoteAddress) return
    let level = 'low'
    if (wire._uploadThrottle._group === client.throttleGroups.mid) level = 'mid'
    if (wire._uploadThrottle._group === client.throttleGroups.high) level = 'high'
    let downloadSpeed = 0, uploadSpeed = 0
    if (speeder.has(wire._debugId)) {
      const prev = speeder.get(wire._debugId)
      downloadSpeed = (wire.downloaded - prev.downloaded) / deltaTime
      uploadSpeed = (wire.uploaded - prev.uploaded) / deltaTime
    }
    speeder.set(wire._debugId, {
      downloaded: wire.downloaded,
      uploaded: wire.uploaded
    })
    o.connections.push({
      id: wire.peerId,
      address: wire.remoteAddress,
      isAbPeer: wire._is_alphabiz_peer_,
      hasMeta: wire.remote_has_meta,
      uploadSpeed,
      downloadSpeed,
      user: wire.remoteUser,
      subId: wire.remoteSub,
      transactions: wire.transactions,
      remoteGroup: wire.remoteGroup,
      downloaded: wire.downloaded,
      level
    })
  })
  o.connections.sort((a, b) => {
    if (!a.address || !a.address.localeCompare) return 0
    return a.address.localeCompare(b.address)
  })
  return o
}

export default {
  torrentToJson
}
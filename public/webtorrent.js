const WebTorrent = require('webtorrent')
const wtVersion = require('webtorrent/package.json').version
const { ipcRenderer } = require('electron')
const crypto = require('crypto')
const fs = require('fs')
const path = require('path')
// const diskusage = require('diskusage')
const FSChunkStore = require('fs-chunk-store')

import { useAlphabizProtocol, useClientEvents } from './wt-extention.js'
import utils from './webtorrent-utils.js'

/**
 * @typedef { import('../src/types').TrackerStatus } TrackerStatus
 */
/**
 * @class TrackerMap
 * @extends { Map<string, TrackerStatus> }
 */
class TrackerMap extends Map {
  /**
   * @method set
   * @param { string } key
   * @param { TrackerStatus } value
   */
  set (key, value) {
    super.set(key, Object.assign(
      { url: key },
      (typeof value === 'object' ? value : { value }),
      { timestamp: Date.now() }
    ))
  }
}

let info = () => {} // console.log
let verbose = () => {} // console.log
// Use this to keep logger with correct caller line
Object.defineProperty(global, 'log', {
  set (v) {
    if (v) info = console.log
    else info = () => {}
    console.log('Toggle log', v)
  }
})
Object.defineProperty(global, 'verb', {
  set (v) {
    if (v) verbose = console.log
    else verbose = () => {}
    console.log('Toggle verb', v)
  }
})
const warn = console.error
if (process.env.NODE_ENV === 'development') {
  // global.log = true
  // global.verb = true
}

const infoHashes = []
const shouldDelete = []
const responseTorrentProps = [
  'infoHash', 'name',
  'paused', 'length',
  'downloaded',// 'downloadSpeed',
  'uploaded',// 'uploadSpeed',
  'ready', 'waiting', 'progress',
  'isSeeding', 'upload',
  // the 'token' is generated by client
  'token', 'completed',
  // the 'origin' marks origin magnet link or torrent
  'origin', 'path',
  'pending',
  // seeding file
  'file', 'magnetURI',
  'isAutoUpload',
  // timers
  'createdTime',
  'completedTime',
  'usedTime'
]
/**
 * @typedef { import('../src/types').TorrentInfo } TorrentInfo
 * @typedef { import('webtorrent/lib/torrent') } RawTorrent
 * @typedef { RawTorrent & TorrentInfo } Torrent
 */
// The lib `speedometer` webtorrent dependents performed bad.
// Use customized speeder instead.
const speeder = new Map()
let prevTime = Date.now()
let deltaTime = 1000
/**
 * @method torrentToJson
 * @param { Torrent } tr
 * @param { boolean } isUpload
 * @returns { Partial<Torrent> }
 */
const torrentToJson = (tr) => {
  return utils.torrentToJson(tr, deltaTime, speeder)
}
/** @param { number } speed */
const speedLimit = speed => {
  if (typeof speed !== 'number') return -1
  return speed > 0 ? parseInt(speed) : -1
}
/** @param { string[] } paths */
const getPublicPath = (paths) => {
  if (!paths || paths.length === 0) return ''
  let dir = path.dirname(paths[0])
  for (let i = 1; i < paths.length; i++) {
    while (!paths[i].includes(dir) && dir.length > 1) {
      dir = path.dirname(dir)
    }
  }
  return dir
}

const locked = new Set()

/**
 * @typedef { import('src/types').TorrentInfo } TorrentInfo
 * @typedef { import('webtorrent/lib/torrent') } RawTorrent
 * @typedef { RawTorrent & TorrentInfo } Torrent
 */

window.WEBTORRENT_ANNOUCEMENT = require('create-torrent').announceList
  .map(arr => arr[0])

const VERSION_STR = wtVersion
  .replace(/\d*./g, v => `0${v % 100}`.slice(-2))
  .slice(0, 4)
const peerId = Buffer.from(`-AB${VERSION_STR}-${crypto.randomBytes(9).toString('base64')}`)

/** @type { WebTorrent } */
let client = null
const initClient = (retries = 0) => {
  if (retries > 10) return
  if (client) {
    if (client.torrents.length) return info('Client is not idle, keep it alive')
  }

  const conf = { peerId }
  const dhtPort = parseInt(localStorage.getItem('dhtPort'))
  const torrentPort = parseInt(localStorage.getItem('torrentPort'))
  if (!isNaN(dhtPort)) conf.dhtPort = dhtPort
  if (!isNaN(torrentPort)) conf.torrentPort = torrentPort
  const maxConns = parseInt(localStorage.getItem('maximumConnectionsNum'))
  if (!isNaN(maxConns)) conf.maxConns = maxConns
  const downloadSpeed = parseInt(localStorage.getItem('downloadSpeed'))
  const uploadSpeed = parseInt(localStorage.getItem('uploadSpeed'))
  const payedUserShareRate = Number(localStorage.getItem('payedUserShareRate'))
  // block local IP
  conf.blocklist = utils.getLocalIPList() || []

  info('init client', conf)
  client = new WebTorrent(conf)
  if (!isNaN(downloadSpeed)) client.throttleDownload(downloadSpeed)
  if (!isNaN(uploadSpeed) && !isNaN(payedUserShareRate)) client.throttleUpload(uploadSpeed, payedUserShareRate)
  client.on('error', e => {
    warn(e)
    if (dhtPort && torrentPort) {
      retries += 1
      info('try use difference port')
      localStorage.setItem('dhtPort', dhtPort + retries)
      localStorage.setItem('torrentPort', torrentPort + retries)
      initClient(retries)
    }
    ipcRenderer.send('webtorrent-client-error', e.message)
  })
  client.on('warning', e => {
    warn(e)
    ipcRenderer.send('webtorrent-client-warn', e.message)
  })
  client.on('ready', () => {
    ipcRenderer.send('webtorrent-initted')
  })
  window.client = client
  useClientEvents(client)
}

/**
 * @param { string | Torrent } infoHash
 * @param { string } url
 */
const addTracker = (infoHash, url) => {
  /** @type { Torrent } */
  const tr = typeof infoHash === 'string' ? client.get(infoHash) : infoHash
  if (!tr || !tr.trackerMap) return
  tr.trackerMap.set(url, { status: 'connecting' })
  utils.addTracker(tr, url)
}
/**
 * @param { string | Torrent } infoHash
 * @param { string } url
 */
const removeTracker = (infoHash, url) => {
  /** @type { Torrent } */
  const tr = typeof infoHash === 'string' ? client.get(infoHash) : infoHash
  if (!tr || !tr.trackerMap) return
  utils.removeTracker(tr, url, () => {
    tr.trackerMap.delete(url)
  })
}
global.addTracker = addTracker
global.removeTracker = removeTracker

/**
 * `setTimeout` cannot be triggered if client is busy.
 * Here we use rAF to ensure out callback runs as fast as posible
 */
const queueTimeout = (cb, timeout) => {
  const start = Date.now()
  const run = () => {
    if (Date.now() - start >= timeout) cb()
    else requestAnimationFrame(run)
  }
  requestAnimationFrame(run)
}
let shouldSendInfo = true
const updateTorrent = () => {
  // console.time('torrent status')
  if (!shouldSendInfo) {
    queueTimeout(updateTorrent, 1000)
    return info('skip send')
  } else {
    verbose('update torrent')
  }
  const curTime = Date.now()
  deltaTime = (curTime - prevTime) / 1000
  prevTime = curTime
  let totalDownloadSpeed = 0
  let totalUploadSpeed = 0
  if (client.torrents.length) {
    const torrents = client.torrents.filter(i => {
      if (shouldDelete.includes(i.infoHash)) return false
      if (i.isAutoUpload && !i.ready) return false
      return true
    }).map(tr => {
      if (!tr.done && typeof tr.usedTime === 'number') tr.usedTime += 1000
      const t = torrentToJson(tr)
      if (!speeder.has(t.infoHash) || !tr.ready) {
        t.downloadSpeed = 0
        t.uploadSpeed = 0
        speeder.set(t.infoHash, {
          downloaded: 0,
          uploaded: 0
        })
      } else {
        const prev = speeder.get(t.infoHash)
        if (prev.downloaded === 0) t.downloadSpeed = 0
        else t.downloadSpeed = Math.floor((tr.downloaded - prev.downloaded) / deltaTime)
        if (prev.uploaded === 0) t.uploadSpeed = 0
        else t.uploadSpeed = Math.floor((tr.uploaded - prev.uploaded) / deltaTime)
        // if (!t.upload) info(prev.downloaded, tr.downloaded, t.downloadSpeed, deltaTime)
        totalDownloadSpeed += t.downloadSpeed
        totalUploadSpeed += t.uploadSpeed
        speeder.set(t.infoHash, {
          downloaded: tr.downloaded,
          uploaded: tr.uploaded
        })
      }
      return t
    })
    // info('send torrents', torrents)
    // window._torrents = torrents
    // torrents.forEach(tr => ipcRenderer.send('webtorrent-data', tr))
    ipcRenderer.send('webtorrent-torrents', torrents)
  } else if (client.ready) {
    ipcRenderer.send('webtorrent-torrents', [])
  }
  ipcRenderer.send('webtorrent-client-info', {
    downloadSpeed: totalDownloadSpeed,
    uploadSpeed: totalUploadSpeed,
    progress: client.progress,
    taskNum: client.torrents.length
  })
  // console.timeEnd('torrent status')
  // if there are too many torrents in the client
  // send info every seconds may cause performance issue
  if (client.torrents.length > 50) {
    client.maxConns = Math.min(client.maxConns, 10)
  }
  if (client.torrents.length > 100) {
    client.maxConns = Math.min(client.maxConns, 5)
    queueTimeout(updateTorrent, 2000)
  } else queueTimeout(updateTorrent, 1000)
}
queueTimeout(updateTorrent, 1000)

const onDone = (tr) => {
  if (tr.upload) return
  tr.isSeeding = true
  const json = torrentToJson(tr)
  ipcRenderer.send('webtorrent-done', json)
  ipcRenderer.send('webtorrent-finish-all-payments', json)
  if (!tr.completedTime) tr.completedTime = Date.now()
}
/** @param { RawTorrent } tr */
const onReady = (tr) => {
  tr.files.forEach(/** @param { import('webtorrent/lib/file') } f */f => {
    // BitComet 0.85+ uses these files itself but will never seed them,
    // We just ignore them since we can do nothing to them.
    if (f.name.match(/^_____padding_file_(.*)____$/)) {
      console.log('deselect', f.name)
    }
  })
  const json = torrentToJson(tr)
  info('ready', json)
  ipcRenderer.send('webtorrent-ready', json)
  // diskusage.check(tr.path, (err, result) => {
  //   if (err) warn(err)
  //   else {
  //     const { free } = result
  //     if (tr.length - tr.downloaded > free + 100_000_000) {
  //       ipcRenderer.send('webtorrent-no-space', json)
  //       stopTorrent(tr.infoHash)
  //     }
  //   }
  // })
  if (client.torrents.filter(i => !i.ready).length === 0) {
    info('All torrents are ready')
  }
}
const onMetadata = (tr, conf) => {
  // info('metadata', torrentToJson({ ...conf, ...tr }))
  ipcRenderer.send('webtorrent-metadata', tr.infoHash)
  ipcRenderer.send('webtorrent-data', torrentToJson(tr))
}
const onWire = (wire, tr) => {
  wire.use(useAlphabizProtocol(client, tr))
}
const onInfoHash = (infoHash, tr, conf, isSeeding) => {
  info('infoHash', infoHash)
  if (shouldDelete.includes(infoHash)) {
    shouldDelete.splice(shouldDelete.indexOf(infoHash), 1)
  }
  if (infoHashes.includes(infoHash)) {
    if (client.get(infoHash) !== tr) {
      info('Destroy tr')
      ipcRenderer.send('webtorrent-existed', infoHash)
      tr.destroy()
    } else {
      ipcRenderer.send('webtorrent-infohash', infoHash, { ...conf, isSeeding })
    }
  }
  else ipcRenderer.send('webtorrent-infohash', infoHash, { ...conf, isSeeding })
  infoHashes.push(infoHash)
}
/**
 * @function addListeners
 * @param { Torrent } tr
 * @param { TorrentInfo } conf
 * @param { boolean } isSeeding
 */
const addListeners = (tr, conf = {}, isSeeding = false) => {
  if (!conf) conf = {}
  tr.pending = false
  tr.removeAllListeners()
  tr.setMaxListeners(0)
  info(`Add listeners to torrent ${tr.infoHash || tr.token || tr.origin}`)
  // tr.on('download', throttle(() => {
  //   ipcRenderer.send('webtorrent-data', torrentToJson(tr))
  // }))
  tr.on('done', () => onDone(tr))
  tr.on('ready', () => onReady(tr))
  tr.on('metadata', () => onMetadata(tr, conf))
  tr.on('infoHash', infoHash => {
    onInfoHash(infoHash, tr, conf, isSeeding)
  })
  tr.on('warning', () => {})
  tr.on('error', e => {
    info('Torrent error', e, conf)
    ipcRenderer.send('webtorrent-error', torrentToJson(tr), e.message)
  })
  tr.on('wire', wire => onWire(wire, tr))
  tr.on('discovery', () => {
    if (tr.discovery) {
      console.log('start discovery')
      tr.trackerMap = new TrackerMap()
      // init map
      tr.discovery._announce.forEach(url => {
        tr.trackerMap.set(url, { status: 'connecting' })
      })
      tr.discovery.tracker.on('warning', (error, url) => {
        console.log('tracker warning', url, error.message)
        if (!url) return console.warn('No emitted url', error)
        tr.trackerMap.set(url, {
          status: 'error',
          message: utils.parseTrackerWarning(error.message)
        })
      })
      // tr.discovery.tracker.on('peer', (...args) => {
      //   console.log('tracker peer', args)
      // })
      tr.discovery.tracker.on('update', (info, url) => {
        // console.log('tracker update', url, info)
        if (!url) return console.warn('No emitted url', info)
        tr.trackerMap.set(url, {
          status: 'updated',
          info
        })
      })
      // tr.discovery.tracker.on('scrape', (...args) => {
      //   console.log('tracker scrape', args)
      // })
      // tr.addTracker = url => utils.addTracker(tr, url)
      // tr.removeTracker = url => utils.removeTracker(tr, url)
      if (conf.customTrackers) {
        for (const tracker of conf.customTrackers) {
          addTracker(tr, tracker)
        }
      }
    } else {
      console.log('no discovery')
    }
  })
}
/**
 * @param { string } token
 * @param { TorrentInfo } conf
 * @param { Function } [cb]
 */
const addTorrent = (token, conf, cb) => {
  // console.log('Add torrent', conf)
  if (conf.isSeeding && conf.progress === 1) return seedTorrent(token, conf.file, conf)
  if (conf.infoHash) {
    const matched = conf.infoHash.match(/btih:([^&]*)/)
    const _hash = (matched && matched[1]) || conf.infoHash
    if (_hash && client.get(_hash)) {
      info('exist', client.get(_hash))
      return ipcRenderer.send('webtorrent-existed', _hash)
    }
  }
  if (conf.origin) {
    if (locked.has(conf.origin)) {
      info('origin lock', conf.origin)
      return locked.delete(conf.origin)
    } else {
      locked.add(conf.origin)
    }
  }
  if (conf.token !== conf.origin) {
    if (locked.has(conf.token)) {
      info('token lock', conf.token)
      info(locked)
      return locked.delete(conf.token)
    } else {
      locked.add(conf.token)
    }
  }
  const add = () => {
    let torrentId = (conf.torrentPath && fs.existsSync(conf.torrentPath))
      ? conf.torrentPath
      : fs.existsSync(conf.token || conf.origin)
        ? conf.token || conf.origin
        : conf.infoHash
    info(torrentId)
    const tr = client.add(torrentId, {
      path: conf.path || conf.downloadDirectory,
      store: FSChunkStore,
      storeCacheSlots: 10,
      strategy: 'sequential',
      maxWebConns: client.maxConns,
      // skipVerify: true,
      announce: [...(conf.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
    tr.token = token
    tr.origin = conf.infoHash || conf.token || conf.origin
    tr.createdTime = conf.createdTime || Date.now()
    tr.usedTime = conf.usedTime || 0
    addListeners(tr, conf)
    tr.once('infoHash', () => {
      locked.delete(conf.origin)
      locked.delete(tr.infoHash)
      locked.delete(conf.token)
      if (cb) cb(tr)
    })
  }
  if (client.get(conf.infoHash)) {
    client.remove(conf.infoHash, add)
  } else if (client.torrents.some(torrent => torrent.token === token)) {
    const tr = client.torrents.find(torrent => torrent.token === token)
    if (tr) {
      if (tr.infoHash) return cb && cb(tr)
      tr.once('infoHash', () => cb && cb(tr))
    } else {
      return add()
    }
  }
  else add()
}
/** @param { string } infoHash */
const stopTorrent = infoHash => {
  if (locked.has(infoHash)) return
  else locked.add(infoHash)
  if (server && serverInfoHash === infoHash) {
    server.destroy()
    server = null
    serverInfoHash = ''
  }
  const tr = client.get(infoHash)
  if (tr && (tr.isSeeding || tr.done)) {
    tr.completed = true
  }
  if (tr) tr.destroy(() => {
    locked.delete(infoHash)
    ipcRenderer.send('webtorrent-stop', infoHash, tr.completed)
  })
  else {
    locked.delete(infoHash)
    if (infoHash) {
      const _tr = client.torrents.find(tr => tr.token === infoHash)
      if (_tr) _tr.destroy(() => {
        locked.delete(infoHash)
        ipcRenderer.send('webtorrent-stop', infoHash, _tr.completed)
      })
    }
    else {
      ipcRenderer.send('webtorrent-notfound', infoHash)
    }
  }
  if (infoHashes.includes(infoHash)) {
    infoHashes.splice(infoHashes.indexOf(infoHash), 1)
  }
}
/**
 * @param { string } infoHash
 * @param { boolean } destroyStore
 */
const deleteTorrent = (infoHash, destroyStore) => {
  if (locked.has(infoHash)) return
  else locked.add(infoHash)
  shouldDelete.push(infoHash)
  if (server && serverInfoHash === infoHash) {
    server.destroy()
    server = null
    serverInfoHash = ''
  }
  const tr = client.get(infoHash) || client.torrents.find(t => t.token === infoHash)
  info('delete', infoHash, tr, destroyStore)
  if (tr) {
    const publicPath = tr.files.length ? getPublicPath(tr.files.map(i => i.path)) : getPublicPath(tr.file || [])
    tr.destroy({ destroyStore }, () => {
      ipcRenderer.send('webtorrent-delete', tr.infoHash || infoHash, publicPath)
      locked.delete(infoHash)
      try {
        client.remove(tr.infoHash)
      } catch (_) { }
    })
  } else {
    locked.delete(infoHash)
    ipcRenderer.send('webtorrent-notfound', infoHash)
  }
  while (infoHashes.includes(infoHash)) {
    infoHashes.splice(infoHashes.indexOf(infoHash), 1)
  }
}
/**
 * @param { string } token
 * @param { string[] } files
 * @param { object } options
 * @param { boolean } isAutoUpload
 * @param { function } callback
 */
const seedTorrent = (token, files, options, isAutoUpload = false, callback = null) => {
  if (options.infoHash) {
    if (locked.has(options.infoHash)) return
    else locked.add(options.infoHash)
  }
  let tr = null
  if (options.infoHash && !options.upload && options.files.length) {
    console.log('[seed] add torrent with token')
    console.log(options)
    tr = client.add(options.token || options.origin || options.infoHash, {
      path: options.path || options.downloadDirectory,
      store: FSChunkStore,
      storeCacheSlots: 10,
      strategy: 'sequential',
      skipVerify: options.progress === 1,
      maxWebConns: client.maxConns,
      announce: [...(options.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
  } else if (options.isSeeding && options.torrentPath && fs.existsSync(options.torrentPath)) {
    console.log('[seed] add torrent with torrentPath')
    tr = client.add(options.torrentPath, {
      path: options.path || options.downloadDirectory,
      store: FSChunkStore,
      storeCacheSlots: 10,
      skipVerify: true,
      maxWebConns: client.maxConns,
      announce: [...(options.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
  } else if (options.isSeeding && options.magnetURI && !options.isUploadByFiles) {
    console.log('[seed] add torrent with magnetURI')
    tr = client.add(options.magnetURI, {
      path: options.path || options.downloadDirectory,
      store: FSChunkStore,
      storeCacheSlots: 10,
      skipVerify: true,
      maxWebConns: client.maxConns,
      announce: [...(options.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
    tr.upload = true
    tr.isSeeding = true
  } else {
    console.log('[seed] Seed torrent with files')
    tr = client.seed(files, {
      ...options,
      store: FSChunkStore,
      storeCacheSlots: 10,
      skipVerify: true,
      maxWebConns: client.maxConns,
      // announce to default list only
      announce: [...(options.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
    tr.isUploadByFiles = true
  }
  info('seedTorrent', options, tr, files)
  if (options.name) tr.name = options.name
  tr.isAutoUpload = isAutoUpload
  tr.token = token
  tr.isSeeding = true
  tr.upload = true
  tr.paused = false
  tr.file = files
  tr.createdTime = options.createdTime || Date.now()
  addListeners(tr, options, true)
  if (options.infoHash) {
    tr.once('infoHash', () => locked.delete(options.infoHash))
  }
  tr.once('infoHash', () => {
    if (callback) callback()
  })
  tr.once('metadata', () => {
    ipcRenderer.send('webtorrent-seed', torrentToJson(tr))
  })
  return tr
}

const getTorrent = () => {
  const torrents = client.torrents.map(i => torrentToJson(i))
  info(torrents)
  return ipcRenderer.send('webtorrent-list', torrents)
}

/**
 * @param { Object } conf
 * @param { 'low'|'mid'|'high' } conf.level
 */
const setThrottleGroup = ({ infoHash, peerId, subId, level }) => {
  const tr = client.get(infoHash)
  if (!tr) {
    info('not found', infoHash)
    ipcRenderer.send('webtorrent-set-throttle', {
      code: -1,
      message: 'Torrent Not Found'
    })
    return null
  }
  let peer = null, error = null
  for (let wire of tr.wires) {
    if (subId ? wire.remoteSub === subId : wire.peerId === peerId) {
      peer = wire
      try {
        wire._setThrottleGroup(level)
      } catch (e) {
        error = { code: -1, message: e.message }
      }
      break
    }
  }
  if (!peer) ipcRenderer.send('webtorrent-set-throttle', {
    code: -1,
    message: 'Peer Not Found'
  })
  else if (error) ipcRenderer.send('webtorrent-set-throttle', error)
  else ipcRenderer.send('webtorrent-set-throttle', {
    code: 0,
    message: 'success'
  })
  return peer
}
const saveTorrentFile = (infoHash, dir) => {
  const channel = 'webtorrent-save-torrent'
  const tr = client.get(infoHash)
  if (!tr) return
  if (!tr.torrentFile || !tr.name) return ipcRenderer.send(channel, {
    code: -1,
    message: 'Torrent Not Ready'
  })
  const torrentPath = path.resolve(dir, `${tr.name}.torrent`)
  fs.writeFileSync(torrentPath, tr.torrentFile)
  ipcRenderer.send(channel, {
    code: 0,
    message: 'success',
    infoHash,
    torrentPath
  })
}

/** @type { ReturnType<import('webtorrent/lib/server')>} */
let server = null
let serverInfoHash = ''
/** @param { Torrent } tr */
const startTorrentServer = tr => {
  info('Start server', tr)
  if (server) {
    // should stop old server and start a new one
    if (serverInfoHash === tr.infoHash) {
      return ipcRenderer.send('webtorrent-server-ready', tr.infoHash, {
        token: tr.token,
        port: server.address().port
      })
    } else {
      server.destroy()
      server = null
      serverInfoHash = ''
    }
  }
  info('Create server', tr)
  server = tr.createServer()
  server.listen(0, () => {
    const port = server.address().port
    const info = {
      token: tr.token,
      port
    }
    ipcRenderer.send('webtorrent-server-ready', tr.infoHash, info)
    const sendProgress = () => {
      const progress = tr.files.map(f => {
        let prog = []
        for (let i = f._startPiece; i < f._endPiece; i++) {
          prog.push(tr.pieces[i] === null ? 1 : 0)
        }
        return {
          name: f.name,
          path: f.path,
          progress: prog
        }
      })
      ipcRenderer.send('webtorrent-server-progress', tr.infoHash, progress)
    }
    setTimeout(sendProgress, 1000)
    // We don't need to update progress very frequently, 5s is enough
    const inter = setInterval(sendProgress, 5000)
    server.once('close', () => clearInterval(inter))
  })
}
const startServer = (infoHash, conf) => {
  info('start server', infoHash, conf)
  let tr = client.get(infoHash)
  if (!tr) {
    return addTorrent(conf.token || conf.infoHash, conf, () => {
      return startServer(infoHash, conf)
    })
  }
  if (tr.ready) {
    startTorrentServer(tr, conf)
  } else {
    tr.once('ready', () => startTorrentServer(tr, conf))
  }
}
const stopServer = () => {
  if (!server) return
  server.destroy()
  server = null
  serverInfoHash = ''
  info('Destroy server')
}

(function init () {
  ipcRenderer.on('add-torrent', (e, token, torrentInfo) => {
    return addTorrent(token, torrentInfo)
  })
  ipcRenderer.on('stop-torrent', (e, infoHash) => {
    info('got stop', infoHash)
    return stopTorrent(infoHash)
  })
  ipcRenderer.on('stop-all-uploading', (e, torrents) => {
    torrents.forEach(tr => {
      const t = client.torrents.find(i => {
        if (i.infoHash && i.infoHash === tr.infoHash) return true
        if (i.token && i.token === tr.token) return true
        return false
      })
      if (t) t.destroy()
    })
  })
  ipcRenderer.on('delete-all', (e, type, destroyStore, deleteAutoUpload) => {
    shouldSendInfo = false
    console.log('Delete all', type, destroyStore, deleteAutoUpload)
    const toDeletes = client.torrents.filter(tr => {
      if (type === 'all') return true
      const isUpload = tr.upload || tr.progress === 1 || tr.isSeeding
      if (type === 'upload') {
        if (!deleteAutoUpload && tr.isAutoUpload) return false
        return isUpload
      }
      return !isUpload
    })
    if (!toDeletes.length) {
      shouldSendInfo = true
      return
    }
    // ensure all torrents are deleted
    let end = 0
    toDeletes.forEach(tr => {
      end++
      console.log(tr.infoHash)
      shouldDelete.push(tr.infoHash)
      tr.removeAllListeners()
      try {
        tr.destroy({ destroyStore }, () => {
          if (shouldDelete.includes(tr.infoHash)) {
            shouldDelete.splice(shouldDelete.indexOf(tr.infoHash), 1)
          }
          end--
          if (end === 0) shouldSendInfo = true
        })
      } catch(e) { }
    })
    // avoid something go wrong
    setTimeout(() => {
      shouldSendInfo = true
    }, 2000)
  })
  ipcRenderer.on('seed-torrent', (e, torrentInfo) => {
    let { file, token, ...options } = torrentInfo
    // for downloaded torrents
    if (!file) file = torrentInfo.files.map(i => i.path)
    info(torrentInfo)
    if (!file.length) return ipcRenderer.send('seed-error')
    if (!token) token = Math.random().toString().substr(2)
    return seedTorrent(token, file, options)
  })
  ipcRenderer.on('autoupload-files', async (e, files) => {
    info('autoupload files', files)
    Promise.all(files.map(file => {
      info('Auto upload', file)
      // if file is already uploaded, ignore it
      if (client.torrents.some(/** @param { Torrent } tr */tr => {
        return tr.files.some(f => {
          return f.path === file
        }) || (tr.file && tr.file.some && tr.file.some(f => f === file)) || tr.file === file
      })) {
        info(`${file} is already uploaded, skipped`)
        return
      }
      return new Promise(resolve => {
        seedTorrent(
          'autoupload-' + file,
          file,
          {},
          true,
          resolve
        )
      })
    })).then(() => {
      info('autoupload complete')
      ipcRenderer.send('autoupload-complete')
    }).catch((error) => {
      ipcRenderer.send('autoupload-complete', error.message || error)
    })
    // Call tr#destroy in torrents.forEach may cause undefined behavior
    // since tr#destory will remove it from torrents
    // Save references before destroy them
    let toDestroy = []
    client.torrents.forEach(/** @param { Torrent } tr */ tr => {
      if (tr.isAutoUpload && tr.ready) {
        if (!tr.files.some(f => files.includes(f.path))) {
          // remove deleted file
          info(`${tr.infoHash} has been deleted. Destroy`, tr.files.map(i => i.path))
          // tr.destroy(() => {
          //   ipcRenderer.send('webtorrent-delete', tr.infoHash)
          // })
          toDestroy.push(tr)
        } else {
          info(`${tr.infoHash} is kept alive`)
        }
      }
    })
    toDestroy.forEach(tr => {
      tr.destroy(() => {
        ipcRenderer.send('webtorrent-delete', tr.infoHash)
      })
    })
  })
  ipcRenderer.on('start-server', (e, { infoHash, conf }) => {
    return startServer(infoHash, conf)
  })
  ipcRenderer.on('stop-server', () => stopServer())
  ipcRenderer.on('delete-torrent', (e, infoHash, destroyStore) => {
    return deleteTorrent(infoHash, destroyStore)
  })
  ipcRenderer.on('pend-torrent', (e, conf) => {
    const tr = client.get(conf.infoHash)
    if (infoHashes.includes(conf.infoHash)) {
      infoHashes.splice(infoHashes.indexOf(conf.infoHash), 1)
    }
    info('Pend', conf.infoHash, tr)
    if (tr) {
      tr.removeAllListeners()
      tr.destroy()
      tr.pending = true
      ipcRenderer.send('webtorrent-pending', torrentToJson(tr))
    }
  })
  ipcRenderer.on('set-throttle-group', (e, { infoHash, peerId, subId, level }) => {
    info(infoHash, peerId, subId, level)
    setThrottleGroup({infoHash, peerId, subId, level })
  })
  ipcRenderer.on('save-torrent-file', (e, infoHash, dir) => saveTorrentFile(infoHash, dir))
  ipcRenderer.on('update-settings', (e, {
    uploadSpeed,
    downloadSpeed,
    maximumConnectionsNum,
    DHTlistenPort,
    BTlistenPort,
    payedUserShareRate
  }) => {
    // old versions use string, but now number
    const dhtPort = parseInt(DHTlistenPort)
    const torrentPort = parseInt(BTlistenPort)
    info('Set client', {
      uploadSpeed,
      downloadSpeed,
      maximumConnectionsNum,
      dhtPort,
      torrentPort,
      payedUserShareRate
    })
    if (payedUserShareRate) {
      const shareRate = Number(payedUserShareRate) || 0.7
      localStorage.setItem('payedUserShareRate', shareRate.toString())
    }
    if (uploadSpeed) {
      const limit = speedLimit(uploadSpeed)
      localStorage.setItem('uploadSpeed', limit.toString())
    }
    const shareRate = Number(localStorage.getItem('payedUserShareRate')) || 0.7
    const limit = parseInt(localStorage.getItem('uploadSpeed'))
    if (!isNaN(shareRate) && !isNaN(limit)) {
      if (limit === -1) client.throttleUpload(-1)
      else client.throttleUpload(limit, shareRate)
    }
    if (downloadSpeed) {
      const limit = speedLimit(downloadSpeed)
      client.throttleDownload(limit)
      localStorage.setItem('downloadSpeed', limit.toString())
    }
    if (maximumConnectionsNum) {
      client.maxConns = maximumConnectionsNum
      localStorage.setItem('maximumConnectionsNum', maximumConnectionsNum.toString())
    }
    let shouldRestart = false
    if (dhtPort && dhtPort !== parseInt(localStorage.getItem('dhtPort'))) {
      shouldRestart = true
      localStorage.setItem('dhtPort', dhtPort.toString())
    }
    if (torrentPort && torrentPort !== parseInt(localStorage.getItem('torrentPort'))) {
      shouldRestart = true
      localStorage.setItem('torrentPort', torrentPort.toString())
    }
    if (shouldRestart) {
      // process.exit(0)
      // process.exit makes devtools unaccessable, use reload instead
      location.reload()
    }
  })
  ipcRenderer.on('reset-torrent', () => {
    info('reset')
    shouldSendInfo = false
    Promise.all(client.torrents.map(tr => new Promise(resolve => {
      tr.removeAllListeners()
      tr.destroy({ destroyStore: true }, resolve)
    })))
      .then(() => ipcRenderer.send('webtorrent-reset'))
      .catch(() => ipcRenderer.send('webtorrent-reset-error'))
      .finally(() => {
        info('resetted')
        client.torrents.length = 0
        shouldSendInfo = true
      })
  })
  ipcRenderer.on('add-tracker', (e, { infoHash, url }) => {
    console.log('add-tracker', infoHash, url)
    addTracker(infoHash, url)
  })
  ipcRenderer.on('remove-tracker', (e, { infoHash, url }) => {
    console.log('remove-tracker', infoHash, url)
    removeTracker(infoHash, url)
  })

  initClient(0)
  // ipcRenderer.send('webtorrent-initted')
  window.addEventListener('error', e => {
    info(e.message || e)
    // ipcRenderer.send('webtorrent-window-error', e.error && e.error.message || e.message)
    return true
  })
})()

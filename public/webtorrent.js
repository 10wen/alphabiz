const WebTorrent = require('webtorrent')
const wtVersion = require('webtorrent/package.json').version
const { ipcRenderer } = require('electron')
const crypto = require('crypto')
const fs = require('fs')
const path = require('path')
const FSChunkStore = require('fs-chunk-store')

import { useAlphabizProtocol, useClientEvents } from './wt-extention.js'

const infoHashes = []
const shouldDelete = []
const responseTorrentProps = [
  'infoHash', 'name',
  'paused', 'progress', 'length',
  'downloaded',// 'downloadSpeed',
  'uploaded',// 'uploadSpeed',
  'ready',
  'isSeeding', 'upload',
  // the 'token' is generated by client
  'token', 'completed',
  // the 'origin' marks origin magnet link or torrent
  'origin', 'path',
  'pending',
  // seeding file
  'file', 'magnetURI',
  'isAutoUpload',
  // timers
  'createdTime',
  'completedTime',
  'usedTime'
]
/**
 * @typedef { import('src/types').TorrentInfo } TorrentInfo
 * @typedef { import('webtorrent/lib/torrent') } RawTorrent
 * @typedef { RawTorrent & TorrentInfo } Torrent
 */
// The lib `speedometer` webtorrent dependents performed bad.
// Use customized speeder instead.
const speeder = new Map()
let prevTime = Date.now()
let deltaTime = 1000
/**
 * @method torrentToJson
 * @param { Torrent } tr
 * @param { boolean } isUpload
 * @returns { Partial<Torrent> }
 */
const torrentToJson = (tr) => {
  const o = {}
  responseTorrentProps.forEach(prop => { o[prop] = tr[prop] })
  o.done = tr.downloaded >= tr.length
  o.download = tr.progress !== 1 && !tr.upload
  o.upload = tr.upload
  // hmm, a typo error that is already used everywhere
  o.recieved = tr.received
  o.files = tr.files ? tr.files.map(
    /** @param { import('webtorrent/lib/file') } file */
    file => {
      return {
        name: file.name,
        path: path.resolve(tr.path, file.path),
        progress: file.progress || 0
      }
    }
  ) : []
  if (tr.timeRemaining) o.timeRemaining = tr.timeRemaining
  if (tr.metadata) o.hasMetadata = true
  if (tr.numPeers) o.peersNum = tr.numPeers
  o.connections = []
  tr.wires.forEach(wire => {
    // if (!wire.remoteAddress) return
    let level = 'low'
    if (wire._uploadThrottle._group === client.throttleGroups.mid) level = 'mid'
    if (wire._uploadThrottle._group === client.throttleGroups.high) level = 'high'
    let downloadSpeed = 0, uploadSpeed = 0
    if (speeder.has(wire._debugId)) {
      const prev = speeder.get(wire._debugId)
      downloadSpeed = (wire.downloaded - prev.downloaded) / deltaTime
      uploadSpeed = (wire.uploaded - prev.uploaded) / deltaTime
    }
    speeder.set(wire._debugId, {
      downloaded: wire.downloaded,
      uploaded: wire.uploaded
    })
    o.connections.push({
      id: wire.peerId,
      address: wire.remoteAddress,
      isAbPeer: wire._is_alphabiz_peer_,
      uploadSpeed,
      downloadSpeed,
      user: wire.remoteUser,
      subId: wire.remoteSub,
      transactions: wire.transactions,
      remoteGroup: wire.remoteGroup,
      downloaded: wire.downloaded,
      level
    })
  })
  o.connections.sort((a, b) => {
    if (!a.address || !a.address.localeCompare) return 0
    return a.address.localeCompare(b.address)
  })
  return o
}
/** @param { number } speed */
const speedLimit = speed => {
  if (typeof speed !== 'number') return -1
  return speed > 0 ? parseInt(speed) : -1
}
/** @param { string[] } paths */
const getPublicPath = (paths) => {
  if (!paths || paths.length === 0) return ''
  let dir = path.dirname(paths[0])
  for (let i = 1; i < paths.length; i++) {
    while (!paths[i].includes(dir) && dir.length > 1) {
      dir = path.dirname(dir)
    }
  }
  return dir
}

const info = console.log
const warn = console.error

const locked = new Set()

/**
 * @typedef { import('src/types').TorrentInfo } TorrentInfo
 * @typedef { import('webtorrent/lib/torrent') } RawTorrent
 * @typedef { RawTorrent & TorrentInfo } Torrent
 */

window.WEBTORRENT_ANNOUCEMENT = require('create-torrent').announceList
  .map(arr => arr[0])

const VERSION_STR = wtVersion
  .replace(/\d*./g, v => `0${v % 100}`.slice(-2))
  .slice(0, 4)
const peerId = Buffer.from(`-AB${VERSION_STR}-${crypto.randomBytes(9).toString('base64')}`)

/** @type { WebTorrent } */
let client = null
const initClient = (retries = 0) => {
  if (retries > 10) return
  if (client) {
    if (client.torrents.length) return info('Client is not idle, keep it alive')
  }
  const conf = { peerId }
  const dhtPort = parseInt(localStorage.getItem('dhtPort'))
  const torrentPort = parseInt(localStorage.getItem('torrentPort'))
  if (!isNaN(dhtPort)) conf.dhtPort = dhtPort
  if (!isNaN(torrentPort)) conf.torrentPort = torrentPort
  const downloadLimit = parseInt(localStorage.getItem('downloadLimit'))
  const uploadLimit = parseInt(localStorage.getItem('uploadLimit'))
  const highLevelRadix = parseInt(localStorage.getItem('highLevelRadix'))
  info('init client', conf)
  client = new WebTorrent(conf)
  if (!isNaN(downloadLimit)) client.throttleDownload(downloadLimit)
  if (!isNaN(uploadLimit) && !isNaN(highLevelRadix)) client.throttleUpload(uploadLimit, highLevelRadix)
  client.on('error', e => {
    console.error(e)
    if (dhtPort && torrentPort) {
      retries += 1
      console.log('try use difference port')
      localStorage.setItem('dhtPort', dhtPort + retries)
      localStorage.setItem('torrentPort', torrentPort + retries)
      initClient(retries)
    }
    ipcRenderer.send('webtorrent-client-error', e.message)
  })
  client.on('warning', e => {
    console.warn(e)
    ipcRenderer.send('webtorrent-client-warn', e.message)
  })
  client.on('ready', () => {
    ipcRenderer.send('webtorrent-initted')
  })
  window.client = client
  useClientEvents(client)
}

let shouldSendInfo = true
const updateTorrent = () => {
  // console.time('torrent status')
  if (!shouldSendInfo) {
    setTimeout(updateTorrent, 1000)
    return info('skip send')
  }
  const curTime = Date.now()
  deltaTime = (curTime - prevTime) / 1000
  prevTime = curTime
  let totalDownloadSpeed = 0
  let totalUploadSpeed = 0
  if (client.torrents.length) {
    const torrents = client.torrents.filter(i => {
      if (shouldDelete.includes(i.infoHash)) return false
      if (i.isAutoUpload && !i.ready) return false
      return true
    }).map(tr => {
      if (!tr.done && typeof tr.usedTime === 'number') tr.usedTime += 1000
      const t = torrentToJson(tr)
      if (!speeder.has(t.infoHash) || !tr.ready) {
        t.downloadSpeed = 0
        t.uploadSpeed = 0
        speeder.set(t.infoHash, {
          downloaded: 0,
          uploaded: 0
        })
      } else {
        const prev = speeder.get(t.infoHash)
        if (prev.downloaded === 0) t.downloadSpeed = 0
        else t.downloadSpeed = Math.floor((tr.downloaded - prev.downloaded) / deltaTime)
        if (prev.uploaded === 0) t.uploadSpeed = 0
        else t.uploadSpeed = Math.floor((tr.uploaded - prev.uploaded) / deltaTime)
        // if (!t.upload) info(prev.downloaded, tr.downloaded, t.downloadSpeed, deltaTime)
        totalDownloadSpeed += t.downloadSpeed
        totalUploadSpeed += t.uploadSpeed
        speeder.set(t.infoHash, {
          downloaded: tr.downloaded,
          uploaded: tr.uploaded
        })
      }
      return t
    })
    // info('send torrents', torrents)
    window._torrents = torrents
    // torrents.forEach(tr => ipcRenderer.send('webtorrent-data', tr))
    ipcRenderer.send('webtorrent-torrents', torrents)
  } else if (client.ready) {
    ipcRenderer.send('webtorrent-torrents', [])
  }
  ipcRenderer.send('webtorrent-client-info', {
    downloadSpeed: totalDownloadSpeed,
    uploadSpeed: totalUploadSpeed,
    progress: client.progress,
    taskNum: client.torrents.length
  })
  // console.timeEnd('torrent status')
  // if there are too many torrents in the client
  // send info every seconds may cause performance issue
  if (client.torrents.length > 300) setTimeout(updateTorrent, 2000)
  else setTimeout(updateTorrent, 1000)
}
setTimeout(updateTorrent, 1000)
/** @param { Torrent } tr */
const addListeners = (tr, conf = {}, isSeeding = false) => {
  if (!conf) conf = {}
  tr.pending = false
  tr.removeAllListeners()
  tr.setMaxListeners(0)
  info(`Add listeners to torrent ${tr.infoHash || tr.token || tr.origin}`)
  // tr.on('download', throttle(() => {
  //   ipcRenderer.send('webtorrent-data', torrentToJson(tr))
  // }))
  tr.on('done', () => {
    if (tr.upload) return
    // setTimeout(() => {
    //   // const tr = client.get(tr.infoHash)
    //   if (!tr || !tr.isSeeding) return
    //   info('Stop seeding', tr.infoHash)
    //   tr.completed = true
    //   tr?.destroy(() => {
    //     tr.paused = true
    //     ipcRenderer.send('webtorrent-stop', tr.infoHash, true)
    //   })
    //   // Defaultly seed torrent for 30 min
    //   // TODO: make this configurables
    //   // toggle following lines for dev or prod
    //   // }, 60 * 1000)
    //   ipcRenderer.send('webtorrent-done', torrentToJson(tr))
    // }, 60 * 1000)
    tr.isSeeding = true
    const json = torrentToJson(tr)
    ipcRenderer.send('webtorrent-done', json)
    ipcRenderer.send('webtorrent-finish-all-payments', json)
    if (!tr.completedTime) tr.completedTime = Date.now()
  })
  tr.on('ready', () => {
    info('ready', torrentToJson(tr))
    ipcRenderer.send('webtorrent-ready', torrentToJson(tr))
  })
  tr.on('metadata', () => {
    info('metadata', torrentToJson({ ...conf, ...tr }))
    ipcRenderer.send('webtorrent-metadata', tr.infoHash)
    ipcRenderer.send('webtorrent-data', torrentToJson(tr))
  })
  tr.on('infoHash', infoHash => {
    info('infoHash', infoHash)
    if (shouldDelete.includes(infoHash)) {
      shouldDelete.splice(shouldDelete.indexOf(infoHash), 1)
    }
    if (infoHashes.includes(infoHash)) {
      if (client.get(infoHash) !== tr) {
        info('Destroy tr')
        ipcRenderer.send('webtorrent-existed', infoHash)
        tr.destroy()
      } else {
        ipcRenderer.send('webtorrent-infohash', infoHash, { ...conf, isSeeding })
      }
    }
    else ipcRenderer.send('webtorrent-infohash', infoHash, { ...conf, isSeeding })
    infoHashes.push(infoHash)
  })
  tr.on('warning', () => {})
  tr.on('error', e => {
    info('Torrent error', e, conf)
    ipcRenderer.send('webtorrent-error', torrentToJson(tr), e.message)
  })
  tr.on('wire', wire => {
    wire.use(useAlphabizProtocol(client, tr))
  })
}
/**
 * @param { string } token
 * @param { TorrentInfo } conf
 * @param { Function } [cb]
 */
const addTorrent = (token, conf, cb) => {
  info('Add torrent', conf)
  if (conf.isSeeding && conf.progress === 1) return seedTorrent(token, conf.file, conf)
  if (conf.infoHash) {
    const matched = conf.infoHash.match(/btih:([^&]*)/)
    const _hash = matched && matched[1]
    if (_hash && client.get(_hash)) {
      return ipcRenderer.send('webtorrent-existed', _hash)
    }
  }
  if (conf.origin) {
    if (locked.has(conf.origin)) return locked.delete(conf.origin)
    else locked.add(conf.origin)
  }
  const add = () => {
    let torrentId = (conf.torrentPath && fs.existsSync(conf.torrentPath))
      ? conf.torrentPath
      : fs.existsSync(conf.token || conf.origin)
        ? conf.token || conf.origin
        : conf.infoHash
    console.log(torrentId)
    const tr = client.add(torrentId, {
      path: conf.path || conf.downloadDirectory,
      store: FSChunkStore,
      storeCacheSlots: 0,
      strategy: 'sequential',
      announce: [...(conf.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
    tr.token = token
    tr.origin = conf.infoHash || conf.token || conf.origin
    tr.createdTime = conf.createdTime || Date.now()
    tr.usedTime = conf.usedTime || 0
    addListeners(tr, conf)
    tr.once('infoHash', () => {
      locked.delete(conf.origin)
      locked.delete(tr.infoHash)
      if (cb) cb(tr)
    })
  }
  if (client.get(conf.infoHash)) {
    client.remove(conf.infoHash, add)
  } else if (client.torrents.some(torrent => torrent.token === token)) {
    const tr = client.torrents.find(torrent => torrent.token === token)
    if (tr) {
      if (tr.infoHash) return cb && cb(tr)
      tr.once('infoHash', () => cb && cb(tr))
    } else {
      return add()
    }
  }
  else add()
}
/** @param { string } infoHash */
const stopTorrent = infoHash => {
  if (locked.has(infoHash)) return
  else locked.add(infoHash)
  if (server && serverInfoHash === infoHash) {
    server.destroy()
    server = null
    serverInfoHash = ''
  }
  const tr = client.get(infoHash)
  if (tr && (tr.isSeeding || tr.done)) {
    tr.completed = true
  }
  if (tr) tr.destroy(() => {
    locked.delete(infoHash)
    ipcRenderer.send('webtorrent-stop', infoHash, tr.completed)
  })
  else {
    locked.delete(infoHash)
    ipcRenderer.send('webtorrent-notfound', infoHash)
  }
  if (infoHashes.includes(infoHash)) {
    infoHashes.splice(infoHashes.indexOf(infoHash), 1)
  }
}
/**
 * @param { string } infoHash
 * @param { boolean } destroyStore
 */
const deleteTorrent = (infoHash, destroyStore) => {
  if (locked.has(infoHash)) return
  else locked.add(infoHash)
  shouldDelete.push(infoHash)
  if (server && serverInfoHash === infoHash) {
    server.destroy()
    server = null
    serverInfoHash = ''
  }
  const tr = client.get(infoHash)
  info('delete', infoHash, tr, destroyStore)
  if (tr) {
    const publicPath = tr.files.length ? getPublicPath(tr.files.map(i => i.path)) : getPublicPath(tr.file || [])
    tr.destroy({ destroyStore }, () => {
      ipcRenderer.send('webtorrent-delete', tr.infoHash || infoHash, publicPath)
      locked.delete(infoHash)
      try {
        client.remove(tr.infoHash)
      } catch (_) { }
    })
  } else {
    locked.delete(infoHash)
    ipcRenderer.send('webtorrent-notfound', infoHash)
  }
  while (infoHashes.includes(infoHash)) {
    infoHashes.splice(infoHashes.indexOf(infoHash), 1)
  }
}
/**
 * @param { string } token
 * @param { string[] } files
 * @param { object } options
 * @param { boolean } isAutoUpload
 * @param { function } callback
 */
const seedTorrent = (token, files, options, isAutoUpload = false, callback = null) => {
  if (options.infoHash) {
    if (locked.has(options.infoHash)) return
    else locked.add(options.infoHash)
  }
  let tr = null
  if (options.infoHash && !options.upload && options.files.length) {
    info('[seed] add torrent')
    tr = client.add(options.token || options.origin || options.infoHash, {
      path: options.path || options.downloadDirectory,
      store: FSChunkStore,
      storeCacheSlots: 0,
      strategy: 'sequential',
      announce: [...(options.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
  } else if (options.isSeeding && options.torrentPath) {
    tr = client.add(options.torrentPath, {
      path: options.path || options.downloadDirectory,
      store: FSChunkStore,
      storeCacheSlots: 0,
      announce: [...(options.trackers || []), ...WEBTORRENT_ANNOUCEMENT]
    })
  } else tr = client.seed(files, {
    ...options,
    // announce to default list only
    announce: [...WEBTORRENT_ANNOUCEMENT]
  })
  tr.isAutoUpload = isAutoUpload
  tr.token = token
  tr.isSeeding = true
  tr.upload = true
  tr.paused = false
  tr.file = files
  tr.createdTime = options.createdTime || Date.now()
  addListeners(tr, options, true)
  if (options.infoHash) {
    tr.once('infoHash', () => locked.delete(options.infoHash))
  }
  tr.once('infoHash', () => {
    if (callback) callback()
  })
  tr.once('metadata', () => {
    ipcRenderer.send('webtorrent-seed', torrentToJson(tr))
  })
  return tr
}

const getTorrent = () => {
  const torrents = client.torrents.map(i => torrentToJson(i))
  info(torrents)
  return ipcRenderer.send('webtorrent-list', torrents)
}

/**
 * @param { Object } conf
 * @param { 'low'|'mid'|'high' } conf.level
 */
const setThrottleGroup = ({ infoHash, peerId, subId, level }) => {
  const tr = client.get(infoHash)
  if (!tr) {
    ipcRenderer.send('webtorrent-set-throttle', {
      code: -1,
      message: 'Torrent Not Found'
    })
    return null
  }
  let peer = null, error = null
  for (let wire of tr.wires) {
    if (subId ? wire.remoteSub === subId : wire.peerId === peerId) {
      peer = wire
      try {
        wire._setThrottleGroup(level)
      } catch (e) {
        error = { code: -1, message: e.message }
      }
      break
    }
  }
  if (!peer) ipcRenderer.send('webtorrent-set-throttle', {
    code: -1,
    message: 'Peer Not Found'
  })
  else if (error) ipcRenderer.send('webtorrent-set-throttle', error)
  else ipcRenderer.send('webtorrent-set-throttle', {
    code: 0,
    message: 'success'
  })
  return peer
}
const saveTorrentFile = (infoHash, dir) => {
  const channel = 'webtorrent-save-torrent'
  const tr = client.get(infoHash)
  if (!tr) return ipcRenderer.send(channel, {
    code: -1,
    message: 'Torrent Not Found'
  })
  if (!tr.torrentFile || !tr.name) return ipcRenderer.send(channel, {
    code: -1,
    message: 'Torrent Not Ready'
  })
  const torrentPath = path.resolve(dir, `${tr.name}.torrent`)
  fs.writeFileSync(torrentPath, tr.torrentFile)
  ipcRenderer.send(channel, {
    code: 0,
    message: 'success',
    infoHash,
    torrentPath
  })
}

/** @type { ReturnType<import('webtorrent/lib/server')>} */
let server = null
let serverInfoHash = ''
/** @param { Torrent } tr */
const startTorrentServer = tr => {
  info('Start server', tr)
  if (server) {
    // should stop old server and start a new one
    if (serverInfoHash === tr.infoHash) {
      return ipcRenderer.send('webtorrent-server-ready', tr.infoHash, {
        token: tr.token,
        port: server.address().port
      })
    } else {
      server.destroy()
      server = null
      serverInfoHash = ''
    }
  }
  info('Create server', tr)
  server = tr.createServer()
  server.listen(0, () => {
    const port = server.address().port
    const info = {
      token: tr.token,
      port
    }
    ipcRenderer.send('webtorrent-server-ready', tr.infoHash, info)
    const sendProgress = () => {
      const progress = tr.files.map(f => {
        let prog = []
        for (let i = f._startPiece; i < f._endPiece; i++) {
          prog.push(tr.pieces[i] === null ? 1 : 0)
        }
        return {
          name: f.name,
          path: f.path,
          progress: prog
        }
      })
      ipcRenderer.send('webtorrent-server-progress', tr.infoHash, progress)
    }
    setTimeout(sendProgress, 1000)
    // We don't need to update progress very frequently, 5s is enough
    const inter = setInterval(sendProgress, 5000)
    server.once('close', () => clearInterval(inter))
  })
}
const startServer = (infoHash, conf) => {
  info('start server', infoHash, conf)
  let tr = client.get(infoHash)
  if (!tr) {
    return addTorrent(conf.token || conf.infoHash, conf, () => {
      return startServer(infoHash, conf)
    })
  }
  if (tr.ready) {
    startTorrentServer(tr, conf)
  } else {
    tr.once('ready', () => startTorrentServer(tr, conf))
  }
}
const stopServer = () => {
  if (!server) return
  server.destroy()
  server = null
  serverInfoHash = ''
  info('Destroy server')
}

(function init () {
  ipcRenderer.on('add-torrent', (e, token, torrentInfo) => {
    return addTorrent(token, torrentInfo)
  })
  ipcRenderer.on('stop-torrent', (e, infoHash) => {
    info('got stop', infoHash)
    return stopTorrent(infoHash)
  })
  ipcRenderer.on('seed-torrent', (e, torrentInfo) => {
    let { file, token, ...options } = torrentInfo
    // for downloaded torrents
    if (!file) file = torrentInfo.files.map(i => i.path)
    info(torrentInfo)
    if (!file.length) return ipcRenderer.send('seed-error')
    if (!token) token = Math.random().toString().substr(2)
    return seedTorrent(token, file, options)
  })
  ipcRenderer.on('autoupload-files', async (e, files) => {
    info('autoupload files', files)
    Promise.all(files.map(file => {
      info('Auto upload', file)
      // if file is already uploaded, ignore it
      if (client.torrents.some(/** @param { Torrent } tr */tr => {
        return tr.files.some(f => {
          return f.path === file
        }) || (tr.file && tr.file.some && tr.file.some(f => f === file)) || tr.file === file
      })) {
        info(`${file} is already uploaded, skipped`)
        return
      }
      return new Promise(resolve => {
        seedTorrent(
          'autoupload-' + file,
          file,
          {},
          true,
          resolve
        )
      })
    })).then(() => {
      info('autoupload complete')
      ipcRenderer.send('autoupload-complete')
    }).catch((error) => {
      ipcRenderer.send('autoupload-complete', error.message || error)
    })
    // Call tr#destroy in torrents.forEach may cause undefined behavior
    // since tr#destory will remove it from torrents
    // Save references before destroy them
    let toDestroy = []
    client.torrents.forEach(/** @param { Torrent } tr */ tr => {
      if (tr.isAutoUpload && tr.ready) {
        if (!tr.files.some(f => files.includes(f.path))) {
          // remove deleted file
          info(`${tr.infoHash} has been deleted. Destroy`, tr.files.map(i => i.path))
          // tr.destroy(() => {
          //   ipcRenderer.send('webtorrent-delete', tr.infoHash)
          // })
          toDestroy.push(tr)
        } else {
          info(`${tr.infoHash} is kept alive`)
        }
      }
    })
    toDestroy.forEach(tr => {
      tr.destroy(() => {
        ipcRenderer.send('webtorrent-delete', tr.infoHash)
      })
    })
  })
  ipcRenderer.on('start-server', (e, { infoHash, conf }) => {
    return startServer(infoHash, conf)
  })
  ipcRenderer.on('stop-server', () => stopServer())
  ipcRenderer.on('delete-torrent', (e, infoHash, destroyStore) => {
    return deleteTorrent(infoHash, destroyStore)
  })
  ipcRenderer.on('pend-torrent', (e, conf) => {
    const tr = client.get(conf.infoHash)
    if (infoHashes.includes(conf.infoHash)) {
      infoHashes.splice(infoHashes.indexOf(conf.infoHash), 1)
    }
    info('Pend', conf.infoHash, tr)
    if (tr) {
      tr.removeAllListeners()
      tr.destroy()
      tr.pending = true
      ipcRenderer.send('webtorrent-pending', torrentToJson(tr))
    }
  })
  ipcRenderer.on('set-throttle-group', (e, { infoHash, peerId, subId, level }) => {
    info(infoHash, peerId, subId, level)
    setThrottleGroup({infoHash, peerId, subId, level })
  })
  ipcRenderer.on('save-torrent-file', (e, infoHash, dir) => saveTorrentFile(infoHash, dir))
  ipcRenderer.on('set-client', (e, {
    uploadLimit,
    downloadLimit,
    maximumConnectionsNum,
    dhtPort,
    torrentPort,
    highLevelRadix
  }) => {
    // old versions use string, but now number
    dhtPort = parseInt(dhtPort)
    torrentPort = parseInt(torrentPort)
    info('Set client', {
      uploadLimit,
      downloadLimit,
      maximumConnectionsNum,
      dhtPort,
      torrentPort,
      highLevelRadix
    })
    if (uploadLimit) {
      const limit = speedLimit(uploadLimit)
      const radix = Number(highLevelRadix) || 0.7
      client.throttleUpload(limit, radix)
      localStorage.setItem('uploadLimit', limit.toString())
      localStorage.setItem('highLevelRadix', radix.toString())
    }
    if (downloadLimit) {
      const limit = speedLimit(downloadLimit)
      client.throttleDownload(limit)
      localStorage.setItem('downloadLimit', limit.toString())
    }
    if (maximumConnectionsNum) {
      client.maxConns = maximumConnectionsNum
      localStorage.setItem('maximumConnectionsNum', maximumConnectionsNum.toString())
    }
    let shouldRestart = false
    if (dhtPort && dhtPort !== parseInt(localStorage.getItem('dhtPort'))) {
      shouldRestart = true
      localStorage.setItem('dhtPort', dhtPort.toString())
    }
    if (torrentPort && torrentPort !== parseInt(localStorage.getItem('torrentPort'))) {
      shouldRestart = true
      localStorage.setItem('torrentPort', torrentPort.toString())
    }
    if (shouldRestart) {
      // process.exit(0)
      // process.exit makes devtools unaccessable, use reload instead
      location.reload()
    }
  })
  ipcRenderer.on('reset-torrent', () => {
    info('reset')
    shouldSendInfo = false
    Promise.all(client.torrents.map(tr => new Promise(resolve => {
      tr.removeAllListeners()
      tr.destroy({ destroyStore: true }, resolve)
    })))
      .then(() => ipcRenderer.send('webtorrent-reset'))
      .catch(() => ipcRenderer.send('webtorrent-reset-error'))
      .finally(() => {
        info('resetted')
        client.torrents.length = 0
        shouldSendInfo = true
      })
  })
  initClient(0)
  // ipcRenderer.send('webtorrent-initted')
  window.addEventListener('error', e => {
    console.log(e.message || e)
    // ipcRenderer.send('webtorrent-window-error', e.error && e.error.message || e.message)
    return true
  })
})()

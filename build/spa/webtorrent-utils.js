const path=require("path"),{networkInterfaces:networkInterfaces}=require("os"),getPieceMap=e=>{if(!e.ready)return[];const t=e.pieces.length,o=t+128-t%128,r=o/128,a=[];let d=1,s=0;for(let n=0;n<o;n++)e.pieces[n]?d&=0:d&=1,s++,s>=r&&(a.push(d),d=1,s=0);return a};export const getByteMap=e=>{const t=getPieceMap(e),o=[];let r=0,a=0;for(let d=0;d<t.length;d++)a|=t[d]<<r,r++,r>=8&&(o.push(a),r=0,a=0);return o};const responseTorrentProps=["infoHash","name","paused","length","downloaded","uploaded","ready","waiting","progress","isSeeding","upload","token","completed","origin","path","pending","file","magnetURI","isAutoUpload","isUploadByFiles","createdTime","completedTime","usedTime"],torrentToJson=(e,t,o)=>{const r={};responseTorrentProps.forEach((t=>{r[t]=e[t]})),r.done=e.downloaded>=e.length,r.download=1!==e.progress&&!e.upload,r.upload=e.upload,r.recieved=e.received,r.files=e.files?e.files.map((t=>({name:t.name,path:path.resolve(e.path,t.path),progress:t.progress>0?t.progress:0}))).filter((e=>!e.name.match(/^_____padding_file_(.*)____$/))):[],e.timeRemaining&&(r.timeRemaining=e.timeRemaining),e.metadata&&(r.hasMetadata=!0),e.numPeers&&(r.peersNum=e.numPeers);const a=getByteMap(e);return e.byteMap&&!a.some(((t,o)=>e.byteMap[o]!==t))||(e.byteMap=a,console.log("change byteMap",a),e.emit("byte-map-change")),r.byteMap=e.byteMap,r.connections=e.wires.map((r=>{let a="low";r._uploadThrottle._group===client.throttleGroups.mid&&(a="mid"),r._uploadThrottle._group===client.throttleGroups.high&&(a="high");let d=0,s=0;if(o.has(r._debugId)){const e=o.get(r._debugId);d=(r.downloaded-e.downloaded)/t,s=(r.uploaded-e.uploaded)/t}o.set(r._debugId,{downloaded:r.downloaded,uploaded:r.uploaded});let n=!1;return e.byteMap&&r.remote_byte_map&&(n=e.byteMap.some(((e,t)=>{try{const o=e.toString(2).padStart(8,"0"),a=r.remote_byte_map[t].toString(2).padStart(8,"0");for(let e=0;e<o.length;e++)if("0"===o[e]&&"1"===a[e])return!0;return!1}catch(o){return!1}}))),{id:r.peerId,address:r.remoteAddress,isAbPeer:r._is_alphabiz_peer_,hasMeta:r.remote_has_meta,hasResource:n,remoteByteMap:r.remote_byte_map||[],uploadSpeed:s,downloadSpeed:d,user:r.remoteUser,subId:r.remoteSub,transactions:r.transactions,remoteGroup:r.remoteGroup,downloaded:r.downloaded,level:a}})),r.connections.sort(((e,t)=>e.address&&e.address.localeCompare?e.address.localeCompare(t.address):0)),r},getLocalIPList=()=>{const e=networkInterfaces(),t=new Set;for(const o in e){const r=e[o];r.forEach((e=>{t.add(e.address)}))}return[...t]};export default{torrentToJson:torrentToJson,getLocalIPList:getLocalIPList,getPieceMap:getPieceMap};
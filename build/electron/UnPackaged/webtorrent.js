const WebTorrent=require("webtorrent"),wtVersion=require("webtorrent/package.json").version,{ipcRenderer:ipcRenderer}=require("electron"),crypto=require("crypto"),fs=require("fs"),path=require("path");import{useAlphabizProtocol,useClientEvents}from"./wt-extention.js";let info=()=>{},verbose=()=>{};Object.defineProperty(global,"log",{set(e){info=e?console.log:()=>{},console.log("Toggle log",e)}}),Object.defineProperty(global,"verb",{set(e){verbose=e?console.log:()=>{},console.log("Toggle verb",e)}});const warn=console.error;process.env.NODE_ENV;const infoHashes=[],shouldDelete=[],responseTorrentProps=["infoHash","name","paused","length","downloaded","uploaded","ready","waiting","progress","isSeeding","upload","token","completed","origin","path","pending","file","magnetURI","isAutoUpload","createdTime","completedTime","usedTime"],speeder=new Map;let prevTime=Date.now(),deltaTime=1e3;const torrentToJson=e=>{const t={};return responseTorrentProps.forEach((o=>{t[o]=e[o]})),t.done=e.downloaded>=e.length,t.download=1!==e.progress&&!e.upload,t.upload=e.upload,t.recieved=e.received,t.files=e.files?e.files.map((t=>({name:t.name,path:path.resolve(e.path,t.path),progress:t.progress>0?t.progress:0}))).filter((e=>!e.name.match(/^_____padding_file_(.*)____$/))):[],e.timeRemaining&&(t.timeRemaining=e.timeRemaining),e.metadata&&(t.hasMetadata=!0),e.numPeers&&(t.peersNum=e.numPeers),t.connections=[],e.wires.forEach((e=>{let o="low";e._uploadThrottle._group===client.throttleGroups.mid&&(o="mid"),e._uploadThrottle._group===client.throttleGroups.high&&(o="high");let r=0,n=0;if(speeder.has(e._debugId)){const t=speeder.get(e._debugId);r=(e.downloaded-t.downloaded)/deltaTime,n=(e.uploaded-t.uploaded)/deltaTime}speeder.set(e._debugId,{downloaded:e.downloaded,uploaded:e.uploaded}),t.connections.push({id:e.peerId,address:e.remoteAddress,isAbPeer:e._is_alphabiz_peer_,hasMeta:e.remote_has_meta,uploadSpeed:n,downloadSpeed:r,user:e.remoteUser,subId:e.remoteSub,transactions:e.transactions,remoteGroup:e.remoteGroup,downloaded:e.downloaded,level:o})})),t.connections.sort(((e,t)=>e.address&&e.address.localeCompare?e.address.localeCompare(t.address):0)),t},speedLimit=e=>"number"!==typeof e?-1:e>0?parseInt(e):-1,getPublicPath=e=>{if(!e||0===e.length)return"";let t=path.dirname(e[0]);for(let o=1;o<e.length;o++)while(!e[o].includes(t)&&t.length>1)t=path.dirname(t);return t},locked=new Set;window.WEBTORRENT_ANNOUCEMENT=require("create-torrent").announceList.map((e=>e[0]));const VERSION_STR=wtVersion.replace(/\d*./g,(e=>("0"+e%100).slice(-2))).slice(0,4),peerId=Buffer.from(`-AB${VERSION_STR}-${crypto.randomBytes(9).toString("base64")}`);let client=null;const initClient=(e=0)=>{if(e>10)return;if(client&&client.torrents.length)return info("Client is not idle, keep it alive");const t={peerId:peerId},o=parseInt(localStorage.getItem("dhtPort")),r=parseInt(localStorage.getItem("torrentPort"));isNaN(o)||(t.dhtPort=o),isNaN(r)||(t.torrentPort=r);const n=parseInt(localStorage.getItem("maximumConnectionsNum"));isNaN(n)||(t.maxConns=n);const s=parseInt(localStorage.getItem("downloadSpeed")),i=parseInt(localStorage.getItem("uploadSpeed")),d=Number(localStorage.getItem("payedUserShareRate"));info("init client",t),client=new WebTorrent(t),isNaN(s)||client.throttleDownload(s),isNaN(i)||isNaN(d)||client.throttleUpload(i,d),client.on("error",(t=>{warn(t),o&&r&&(e+=1,info("try use difference port"),localStorage.setItem("dhtPort",o+e),localStorage.setItem("torrentPort",r+e),initClient(e)),ipcRenderer.send("webtorrent-client-error",t.message)})),client.on("warning",(e=>{warn(e),ipcRenderer.send("webtorrent-client-warn",e.message)})),client.on("ready",(()=>{ipcRenderer.send("webtorrent-initted")})),window.client=client,useClientEvents(client)},queueTimeout=(e,t)=>{const o=Date.now(),r=()=>{Date.now()-o>=t?e():requestAnimationFrame(r)};requestAnimationFrame(r)};let shouldSendInfo=!0;const updateTorrent=()=>{if(!shouldSendInfo)return queueTimeout(updateTorrent,1e3),info("skip send");verbose("update torrent");const e=Date.now();deltaTime=(e-prevTime)/1e3,prevTime=e;let t=0,o=0;if(client.torrents.length){const e=client.torrents.filter((e=>!shouldDelete.includes(e.infoHash)&&!(e.isAutoUpload&&!e.ready))).map((e=>{e.done||"number"!==typeof e.usedTime||(e.usedTime+=1e3);const r=torrentToJson(e);if(speeder.has(r.infoHash)&&e.ready){const n=speeder.get(r.infoHash);0===n.downloaded?r.downloadSpeed=0:r.downloadSpeed=Math.floor((e.downloaded-n.downloaded)/deltaTime),0===n.uploaded?r.uploadSpeed=0:r.uploadSpeed=Math.floor((e.uploaded-n.uploaded)/deltaTime),t+=r.downloadSpeed,o+=r.uploadSpeed,speeder.set(r.infoHash,{downloaded:e.downloaded,uploaded:e.uploaded})}else r.downloadSpeed=0,r.uploadSpeed=0,speeder.set(r.infoHash,{downloaded:0,uploaded:0});return r}));ipcRenderer.send("webtorrent-torrents",e)}else client.ready&&ipcRenderer.send("webtorrent-torrents",[]);ipcRenderer.send("webtorrent-client-info",{downloadSpeed:t,uploadSpeed:o,progress:client.progress,taskNum:client.torrents.length}),client.torrents.length>50&&(client.maxConns=Math.min(client.maxConns,10)),client.torrents.length>100?(client.maxConns=Math.min(client.maxConns,5),queueTimeout(updateTorrent,2e3)):queueTimeout(updateTorrent,1e3)};queueTimeout(updateTorrent,1e3);const onDone=e=>{if(e.upload)return;e.isSeeding=!0;const t=torrentToJson(e);ipcRenderer.send("webtorrent-done",t),ipcRenderer.send("webtorrent-finish-all-payments",t),e.completedTime||(e.completedTime=Date.now())},onReady=e=>{e.files.forEach((e=>{e.name.match(/^_____padding_file_(.*)____$/)&&console.log("deselect",e.name)})),info("ready",torrentToJson(e)),ipcRenderer.send("webtorrent-ready",torrentToJson(e)),0===client.torrents.filter((e=>!e.ready)).length&&info("All torrents are ready")},onMetadata=(e,t)=>{info("metadata",torrentToJson({...t,...e})),ipcRenderer.send("webtorrent-metadata",e.infoHash),ipcRenderer.send("webtorrent-data",torrentToJson(e))},onWire=(e,t)=>{e.use(useAlphabizProtocol(client,t))},onInfoHash=(e,t,o,r)=>{info("infoHash",e),shouldDelete.includes(e)&&shouldDelete.splice(shouldDelete.indexOf(e),1),infoHashes.includes(e)&&client.get(e)!==t?(info("Destroy tr"),ipcRenderer.send("webtorrent-existed",e),t.destroy()):ipcRenderer.send("webtorrent-infohash",e,{...o,isSeeding:r}),infoHashes.push(e)},addListeners=(e,t={},o=!1)=>{t||(t={}),e.pending=!1,e.removeAllListeners(),e.setMaxListeners(0),info(`Add listeners to torrent ${e.infoHash||e.token||e.origin}`),e.on("done",(()=>onDone(e))),e.on("ready",(()=>onReady(e))),e.on("metadata",(()=>onMetadata(e,t))),e.on("infoHash",(r=>onInfoHash(r,e,t,o))),e.on("warning",(()=>{})),e.on("error",(o=>{info("Torrent error",o,t),ipcRenderer.send("webtorrent-error",torrentToJson(e),o.message)})),e.on("wire",(t=>onWire(t,e)))},addTorrent=(e,t,o)=>{if(t.isSeeding&&1===t.progress)return seedTorrent(e,t.file,t);if(t.infoHash){const e=t.infoHash.match(/btih:([^&]*)/),o=e&&e[1]||t.infoHash;if(o&&client.get(o))return info("exist",client.get(o)),ipcRenderer.send("webtorrent-existed",o)}if(t.origin){if(locked.has(t.origin))return info("origin lock",t.origin),locked.delete(t.origin);locked.add(t.origin)}if(t.token!==t.origin){if(locked.has(t.token))return info("token lock",t.token),info(locked),locked.delete(t.token);locked.add(t.token)}const r=()=>{let r=t.torrentPath&&fs.existsSync(t.torrentPath)?t.torrentPath:fs.existsSync(t.token||t.origin)?t.token||t.origin:t.infoHash;info(r);const n=client.add(r,{path:t.path||t.downloadDirectory,storeCacheSlots:10,strategy:"sequential",announce:[...t.trackers||[],...WEBTORRENT_ANNOUCEMENT]});n.token=e,n.origin=t.infoHash||t.token||t.origin,n.createdTime=t.createdTime||Date.now(),n.usedTime=t.usedTime||0,addListeners(n,t),n.once("infoHash",(()=>{locked.delete(t.origin),locked.delete(n.infoHash),locked.delete(t.token),o&&o(n)}))};if(client.get(t.infoHash))client.remove(t.infoHash,r);else if(client.torrents.some((t=>t.token===e))){const t=client.torrents.find((t=>t.token===e));if(!t)return r();if(t.infoHash)return o&&o(t);t.once("infoHash",(()=>o&&o(t)))}else r()},stopTorrent=e=>{if(locked.has(e))return;locked.add(e),server&&serverInfoHash===e&&(server.destroy(),server=null,serverInfoHash="");const t=client.get(e);if(t&&(t.isSeeding||t.done)&&(t.completed=!0),t)t.destroy((()=>{locked.delete(e),ipcRenderer.send("webtorrent-stop",e,t.completed)}));else if(locked.delete(e),e){const t=client.torrents.find((t=>t.token===e));t&&t.destroy((()=>{locked.delete(e),ipcRenderer.send("webtorrent-stop",e,t.completed)}))}else ipcRenderer.send("webtorrent-notfound",e);infoHashes.includes(e)&&infoHashes.splice(infoHashes.indexOf(e),1)},deleteTorrent=(e,t)=>{if(locked.has(e))return;locked.add(e),shouldDelete.push(e),server&&serverInfoHash===e&&(server.destroy(),server=null,serverInfoHash="");const o=client.get(e);if(info("delete",e,o,t),o){const r=o.files.length?getPublicPath(o.files.map((e=>e.path))):getPublicPath(o.file||[]);o.destroy({destroyStore:t},(()=>{ipcRenderer.send("webtorrent-delete",o.infoHash||e,r),locked.delete(e);try{client.remove(o.infoHash)}catch(t){}}))}else locked.delete(e),ipcRenderer.send("webtorrent-notfound",e);while(infoHashes.includes(e))infoHashes.splice(infoHashes.indexOf(e),1)},seedTorrent=(e,t,o,r=!1,n=null)=>{if(o.infoHash){if(locked.has(o.infoHash))return;locked.add(o.infoHash)}let s=null;return o.infoHash&&!o.upload&&o.files.length?(console.log("[seed] add torrent"),console.log(o),s=client.add(o.token||o.origin||o.infoHash,{path:o.path||o.downloadDirectory,storeCacheSlots:10,strategy:"sequential",skipVerify:1===o.progress,announce:[...o.trackers||[],...WEBTORRENT_ANNOUCEMENT]})):o.isSeeding&&o.torrentPath?s=client.add(o.torrentPath,{path:o.path||o.downloadDirectory,storeCacheSlots:10,skipVerify:!0,announce:[...o.trackers||[],...WEBTORRENT_ANNOUCEMENT]}):o.isSeeding&&o.magnetURI?(s=client.add(o.magnetURI,{path:o.path||o.downloadDirectory,storeCacheSlots:10,skipVerify:!0,announce:[...o.trackers||[],...WEBTORRENT_ANNOUCEMENT]}),s.upload=!0,s.isSeeding=!0):s=client.seed(t,{...o,storeCacheSlots:10,skipVerify:!0,announce:[...WEBTORRENT_ANNOUCEMENT]}),info("seedTorrent",o,s,t),o.name&&(s.name=o.name),s.isAutoUpload=r,s.token=e,s.isSeeding=!0,s.upload=!0,s.paused=!1,s.file=t,s.createdTime=o.createdTime||Date.now(),addListeners(s,o,!0),o.infoHash&&s.once("infoHash",(()=>locked.delete(o.infoHash))),s.once("infoHash",(()=>{n&&n()})),s.once("metadata",(()=>{ipcRenderer.send("webtorrent-seed",torrentToJson(s))})),s},getTorrent=()=>{const e=client.torrents.map((e=>torrentToJson(e)));return info(e),ipcRenderer.send("webtorrent-list",e)},setThrottleGroup=({infoHash:e,peerId:t,subId:o,level:r})=>{const n=client.get(e);if(!n)return info("not found",e),ipcRenderer.send("webtorrent-set-throttle",{code:-1,message:"Torrent Not Found"}),null;let s=null,i=null;for(let a of n.wires)if(o?a.remoteSub===o:a.peerId===t){s=a;try{a._setThrottleGroup(r)}catch(d){i={code:-1,message:d.message}}break}return s?i?ipcRenderer.send("webtorrent-set-throttle",i):ipcRenderer.send("webtorrent-set-throttle",{code:0,message:"success"}):ipcRenderer.send("webtorrent-set-throttle",{code:-1,message:"Peer Not Found"}),s},saveTorrentFile=(e,t)=>{const o="webtorrent-save-torrent",r=client.get(e);if(!r)return;if(!r.torrentFile||!r.name)return ipcRenderer.send(o,{code:-1,message:"Torrent Not Ready"});const n=path.resolve(t,`${r.name}.torrent`);fs.writeFileSync(n,r.torrentFile),ipcRenderer.send(o,{code:0,message:"success",infoHash:e,torrentPath:n})};let server=null,serverInfoHash="";const startTorrentServer=e=>{if(info("Start server",e),server){if(serverInfoHash===e.infoHash)return ipcRenderer.send("webtorrent-server-ready",e.infoHash,{token:e.token,port:server.address().port});server.destroy(),server=null,serverInfoHash=""}info("Create server",e),server=e.createServer(),server.listen(0,(()=>{const t=server.address().port,o={token:e.token,port:t};ipcRenderer.send("webtorrent-server-ready",e.infoHash,o);const r=()=>{const t=e.files.map((t=>{let o=[];for(let r=t._startPiece;r<t._endPiece;r++)o.push(null===e.pieces[r]?1:0);return{name:t.name,path:t.path,progress:o}}));ipcRenderer.send("webtorrent-server-progress",e.infoHash,t)};setTimeout(r,1e3);const n=setInterval(r,5e3);server.once("close",(()=>clearInterval(n)))}))},startServer=(e,t)=>{info("start server",e,t);let o=client.get(e);if(!o)return addTorrent(t.token||t.infoHash,t,(()=>startServer(e,t)));o.ready?startTorrentServer(o,t):o.once("ready",(()=>startTorrentServer(o,t)))},stopServer=()=>{server&&(server.destroy(),server=null,serverInfoHash="",info("Destroy server"))};(function(){ipcRenderer.on("add-torrent",((e,t,o)=>addTorrent(t,o))),ipcRenderer.on("stop-torrent",((e,t)=>(info("got stop",t),stopTorrent(t)))),ipcRenderer.on("stop-all-uploading",((e,t)=>{t.forEach((e=>{const t=client.torrents.find((t=>!(!t.infoHash||t.infoHash!==e.infoHash)||!(!t.token||t.token!==e.token)));t&&t.destroy()}))})),ipcRenderer.on("delete-all",((e,t,o,r)=>{shouldSendInfo=!1,console.log("Delete all",t,o,r);const n=client.torrents.filter((e=>{if("all"===t)return!0;const o=e.upload&&1===e.progress&&e.isSeeding;return"upload"===t?!(!r&&e.isAutoUpload)&&o:!o}));if(!n.length)return void(shouldSendInfo=!0);let s=0;n.forEach((t=>{s++,console.log(t.infoHash),shouldDelete.push(t.infoHash),t.removeAllListeners();try{t.destroy({destroyStore:o},(()=>{shouldDelete.includes(t.infoHash)&&shouldDelete.splice(shouldDelete.indexOf(t.infoHash),1),s--,0===s&&(shouldSendInfo=!0)}))}catch(e){}})),setTimeout((()=>{shouldSendInfo=!0}),2e3)})),ipcRenderer.on("seed-torrent",((e,t)=>{let{file:o,token:r,...n}=t;return o||(o=t.files.map((e=>e.path))),info(t),o.length?(r||(r=Math.random().toString().substr(2)),seedTorrent(r,o,n)):ipcRenderer.send("seed-error")})),ipcRenderer.on("autoupload-files",(async(e,t)=>{info("autoupload files",t),Promise.all(t.map((e=>{if(info("Auto upload",e),!client.torrents.some((t=>t.files.some((t=>t.path===e))||t.file&&t.file.some&&t.file.some((t=>t===e))||t.file===e)))return new Promise((t=>{seedTorrent("autoupload-"+e,e,{},!0,t)}));info(`${e} is already uploaded, skipped`)}))).then((()=>{info("autoupload complete"),ipcRenderer.send("autoupload-complete")})).catch((e=>{ipcRenderer.send("autoupload-complete",e.message||e)}));let o=[];client.torrents.forEach((e=>{e.isAutoUpload&&e.ready&&(e.files.some((e=>t.includes(e.path)))?info(`${e.infoHash} is kept alive`):(info(`${e.infoHash} has been deleted. Destroy`,e.files.map((e=>e.path))),o.push(e)))})),o.forEach((e=>{e.destroy((()=>{ipcRenderer.send("webtorrent-delete",e.infoHash)}))}))})),ipcRenderer.on("start-server",((e,{infoHash:t,conf:o})=>startServer(t,o))),ipcRenderer.on("stop-server",(()=>stopServer())),ipcRenderer.on("delete-torrent",((e,t,o)=>deleteTorrent(t,o))),ipcRenderer.on("pend-torrent",((e,t)=>{const o=client.get(t.infoHash);infoHashes.includes(t.infoHash)&&infoHashes.splice(infoHashes.indexOf(t.infoHash),1),info("Pend",t.infoHash,o),o&&(o.removeAllListeners(),o.destroy(),o.pending=!0,ipcRenderer.send("webtorrent-pending",torrentToJson(o)))})),ipcRenderer.on("set-throttle-group",((e,{infoHash:t,peerId:o,subId:r,level:n})=>{info(t,o,r,n),setThrottleGroup({infoHash:t,peerId:o,subId:r,level:n})})),ipcRenderer.on("save-torrent-file",((e,t,o)=>saveTorrentFile(t,o))),ipcRenderer.on("update-settings",((e,{uploadSpeed:t,downloadSpeed:o,maximumConnectionsNum:r,dhtPort:n,torrentPort:s,payedUserShareRate:i})=>{if(n=parseInt(n),s=parseInt(s),info("Set client",{uploadSpeed:t,downloadSpeed:o,maximumConnectionsNum:r,dhtPort:n,torrentPort:s,payedUserShareRate:i}),i){const e=Number(i)||.7;localStorage.setItem("payedUserShareRate",e.toString())}if(t){const e=speedLimit(t);localStorage.setItem("uploadSpeed",e.toString())}const d=Number(localStorage.getItem("payedUserShareRate"))||.7,a=parseInt(localStorage.getItem("uploadSpeed"));if(isNaN(d)||isNaN(a)||(-1===a?client.throttleUpload(-1):client.throttleUpload(a,d)),o){const e=speedLimit(o);client.throttleDownload(e),localStorage.setItem("downloadSpeed",e.toString())}r&&(client.maxConns=r,localStorage.setItem("maximumConnectionsNum",r.toString()));let l=!1;n&&n!==parseInt(localStorage.getItem("dhtPort"))&&(l=!0,localStorage.setItem("dhtPort",n.toString())),s&&s!==parseInt(localStorage.getItem("torrentPort"))&&(l=!0,localStorage.setItem("torrentPort",s.toString())),l&&location.reload()})),ipcRenderer.on("reset-torrent",(()=>{info("reset"),shouldSendInfo=!1,Promise.all(client.torrents.map((e=>new Promise((t=>{e.removeAllListeners(),e.destroy({destroyStore:!0},t)}))))).then((()=>ipcRenderer.send("webtorrent-reset"))).catch((()=>ipcRenderer.send("webtorrent-reset-error"))).finally((()=>{info("resetted"),client.torrents.length=0,shouldSendInfo=!0}))})),initClient(0),window.addEventListener("error",(e=>(info(e.message||e),!0)))})();
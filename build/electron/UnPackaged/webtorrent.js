const WebTorrent=require("webtorrent"),wtVersion=require("webtorrent/package.json").version,{ipcRenderer:ipcRenderer}=require("electron"),crypto=require("crypto"),fs=require("fs"),path=require("path"),FSChunkStore=require("fs-chunk-store");import{useAlphabizProtocol,useClientEvents}from"./wt-extention.js";import utils from"./webtorrent-utils.js";let info=()=>{},verbose=()=>{};Object.defineProperty(global,"log",{set(e){info=e?console.log:()=>{},console.log("Toggle log",e)}}),Object.defineProperty(global,"verb",{set(e){verbose=e?console.log:()=>{},console.log("Toggle verb",e)}});const warn=console.error;process.env.NODE_ENV;const infoHashes=[],shouldDelete=[],responseTorrentProps=["infoHash","name","paused","length","downloaded","uploaded","ready","waiting","progress","isSeeding","upload","token","completed","origin","path","pending","file","magnetURI","isAutoUpload","createdTime","completedTime","usedTime"],speeder=new Map;let prevTime=Date.now(),deltaTime=1e3;const torrentToJson=e=>utils.torrentToJson(e,deltaTime,speeder),speedLimit=e=>"number"!==typeof e?-1:e>0?parseInt(e):-1,getPublicPath=e=>{if(!e||0===e.length)return"";let t=path.dirname(e[0]);for(let n=1;n<e.length;n++)while(!e[n].includes(t)&&t.length>1)t=path.dirname(t);return t},locked=new Set;window.WEBTORRENT_ANNOUCEMENT=require("create-torrent").announceList.map((e=>e[0]));const VERSION_STR=wtVersion.replace(/\d*./g,(e=>("0"+e%100).slice(-2))).slice(0,4),peerId=Buffer.from(`-AB${VERSION_STR}-${crypto.randomBytes(9).toString("base64")}`);let client=null;const initClient=(e=0)=>{if(e>10)return;if(client&&client.torrents.length)return info("Client is not idle, keep it alive");const t={peerId:peerId},n=parseInt(localStorage.getItem("dhtPort")),o=parseInt(localStorage.getItem("torrentPort"));isNaN(n)||(t.dhtPort=n),isNaN(o)||(t.torrentPort=o);const r=parseInt(localStorage.getItem("maximumConnectionsNum"));isNaN(r)||(t.maxConns=r);const s=parseInt(localStorage.getItem("downloadSpeed")),i=parseInt(localStorage.getItem("uploadSpeed")),d=Number(localStorage.getItem("payedUserShareRate"));t.blocklist=utils.getLocalIPList()||[],info("init client",t),client=new WebTorrent(t),isNaN(s)||client.throttleDownload(s),isNaN(i)||isNaN(d)||client.throttleUpload(i,d),client.on("error",(t=>{warn(t),n&&o&&(e+=1,info("try use difference port"),localStorage.setItem("dhtPort",n+e),localStorage.setItem("torrentPort",o+e),initClient(e)),ipcRenderer.send("webtorrent-client-error",t.message)})),client.on("warning",(e=>{warn(e),ipcRenderer.send("webtorrent-client-warn",e.message)})),client.on("ready",(()=>{ipcRenderer.send("webtorrent-initted")})),window.client=client,useClientEvents(client)},queueTimeout=(e,t)=>{const n=Date.now(),o=()=>{Date.now()-n>=t?e():requestAnimationFrame(o)};requestAnimationFrame(o)};let shouldSendInfo=!0;const updateTorrent=()=>{if(!shouldSendInfo)return queueTimeout(updateTorrent,1e3),info("skip send");verbose("update torrent");const e=Date.now();deltaTime=(e-prevTime)/1e3,prevTime=e;let t=0,n=0;if(client.torrents.length){const e=client.torrents.filter((e=>!shouldDelete.includes(e.infoHash)&&!(e.isAutoUpload&&!e.ready))).map((e=>{e.done||"number"!==typeof e.usedTime||(e.usedTime+=1e3);const o=torrentToJson(e);if(speeder.has(o.infoHash)&&e.ready){const r=speeder.get(o.infoHash);0===r.downloaded?o.downloadSpeed=0:o.downloadSpeed=Math.floor((e.downloaded-r.downloaded)/deltaTime),0===r.uploaded?o.uploadSpeed=0:o.uploadSpeed=Math.floor((e.uploaded-r.uploaded)/deltaTime),t+=o.downloadSpeed,n+=o.uploadSpeed,speeder.set(o.infoHash,{downloaded:e.downloaded,uploaded:e.uploaded})}else o.downloadSpeed=0,o.uploadSpeed=0,speeder.set(o.infoHash,{downloaded:0,uploaded:0});return o}));ipcRenderer.send("webtorrent-torrents",e)}else client.ready&&ipcRenderer.send("webtorrent-torrents",[]);ipcRenderer.send("webtorrent-client-info",{downloadSpeed:t,uploadSpeed:n,progress:client.progress,taskNum:client.torrents.length}),client.torrents.length>50&&(client.maxConns=Math.min(client.maxConns,10)),client.torrents.length>100?(client.maxConns=Math.min(client.maxConns,5),queueTimeout(updateTorrent,2e3)):queueTimeout(updateTorrent,1e3)};queueTimeout(updateTorrent,1e3);const onDone=e=>{if(e.upload)return;e.isSeeding=!0;const t=torrentToJson(e);ipcRenderer.send("webtorrent-done",t),ipcRenderer.send("webtorrent-finish-all-payments",t),e.completedTime||(e.completedTime=Date.now())},onReady=e=>{e.files.forEach((e=>{e.name.match(/^_____padding_file_(.*)____$/)&&console.log("deselect",e.name)}));const t=torrentToJson(e);info("ready",t),ipcRenderer.send("webtorrent-ready",t),0===client.torrents.filter((e=>!e.ready)).length&&info("All torrents are ready")},onMetadata=(e,t)=>{ipcRenderer.send("webtorrent-metadata",e.infoHash),ipcRenderer.send("webtorrent-data",torrentToJson(e))},onWire=(e,t)=>{e.use(useAlphabizProtocol(client,t))},onInfoHash=(e,t,n,o)=>{info("infoHash",e),shouldDelete.includes(e)&&shouldDelete.splice(shouldDelete.indexOf(e),1),infoHashes.includes(e)&&client.get(e)!==t?(info("Destroy tr"),ipcRenderer.send("webtorrent-existed",e),t.destroy()):ipcRenderer.send("webtorrent-infohash",e,{...n,isSeeding:o}),infoHashes.push(e)},addListeners=(e,t={},n=!1)=>{t||(t={}),e.pending=!1,e.removeAllListeners(),e.setMaxListeners(0),info(`Add listeners to torrent ${e.infoHash||e.token||e.origin}`),e.on("done",(()=>onDone(e))),e.on("ready",(()=>onReady(e))),e.on("metadata",(()=>onMetadata(e,t))),e.on("infoHash",(o=>onInfoHash(o,e,t,n))),e.on("warning",(()=>{})),e.on("error",(n=>{info("Torrent error",n,t),ipcRenderer.send("webtorrent-error",torrentToJson(e),n.message)})),e.on("wire",(t=>onWire(t,e)))},addTorrent=(e,t,n)=>{if(t.isSeeding&&1===t.progress)return seedTorrent(e,t.file,t);if(t.infoHash){const e=t.infoHash.match(/btih:([^&]*)/),n=e&&e[1]||t.infoHash;if(n&&client.get(n))return info("exist",client.get(n)),ipcRenderer.send("webtorrent-existed",n)}if(t.origin){if(locked.has(t.origin))return info("origin lock",t.origin),locked.delete(t.origin);locked.add(t.origin)}if(t.token!==t.origin){if(locked.has(t.token))return info("token lock",t.token),info(locked),locked.delete(t.token);locked.add(t.token)}const o=()=>{let o=t.torrentPath&&fs.existsSync(t.torrentPath)?t.torrentPath:fs.existsSync(t.token||t.origin)?t.token||t.origin:t.infoHash;info(o);const r=client.add(o,{path:t.path||t.downloadDirectory,store:FSChunkStore,storeCacheSlots:10,strategy:"sequential",maxWebConns:client.maxConns,announce:[...t.trackers||[],...WEBTORRENT_ANNOUCEMENT]});r.token=e,r.origin=t.infoHash||t.token||t.origin,r.createdTime=t.createdTime||Date.now(),r.usedTime=t.usedTime||0,addListeners(r,t),r.once("infoHash",(()=>{locked.delete(t.origin),locked.delete(r.infoHash),locked.delete(t.token),n&&n(r)}))};if(client.get(t.infoHash))client.remove(t.infoHash,o);else if(client.torrents.some((t=>t.token===e))){const t=client.torrents.find((t=>t.token===e));if(!t)return o();if(t.infoHash)return n&&n(t);t.once("infoHash",(()=>n&&n(t)))}else o()},stopTorrent=e=>{if(locked.has(e))return;locked.add(e),server&&serverInfoHash===e&&(server.destroy(),server=null,serverInfoHash="");const t=client.get(e);if(t&&(t.isSeeding||t.done)&&(t.completed=!0),t)t.destroy((()=>{locked.delete(e),ipcRenderer.send("webtorrent-stop",e,t.completed)}));else if(locked.delete(e),e){const t=client.torrents.find((t=>t.token===e));t&&t.destroy((()=>{locked.delete(e),ipcRenderer.send("webtorrent-stop",e,t.completed)}))}else ipcRenderer.send("webtorrent-notfound",e);infoHashes.includes(e)&&infoHashes.splice(infoHashes.indexOf(e),1)},deleteTorrent=(e,t)=>{if(locked.has(e))return;locked.add(e),shouldDelete.push(e),server&&serverInfoHash===e&&(server.destroy(),server=null,serverInfoHash="");const n=client.get(e)||client.torrents.find((t=>t.token===e));if(info("delete",e,n,t),n){const o=n.files.length?getPublicPath(n.files.map((e=>e.path))):getPublicPath(n.file||[]);n.destroy({destroyStore:t},(()=>{ipcRenderer.send("webtorrent-delete",n.infoHash||e,o),locked.delete(e);try{client.remove(n.infoHash)}catch(t){}}))}else locked.delete(e),ipcRenderer.send("webtorrent-notfound",e);while(infoHashes.includes(e))infoHashes.splice(infoHashes.indexOf(e),1)},seedTorrent=(e,t,n,o=!1,r=null)=>{if(n.infoHash){if(locked.has(n.infoHash))return;locked.add(n.infoHash)}let s=null;return n.infoHash&&!n.upload&&n.files.length?(console.log("[seed] add torrent with token"),console.log(n),s=client.add(n.token||n.origin||n.infoHash,{path:n.path||n.downloadDirectory,store:FSChunkStore,storeCacheSlots:10,strategy:"sequential",skipVerify:1===n.progress,maxWebConns:client.maxConns,announce:[...n.trackers||[],...WEBTORRENT_ANNOUCEMENT]})):n.isSeeding&&n.torrentPath&&fs.existsSync(n.torrentPath)?(console.log("[seed] add torrent with torrentPath"),s=client.add(n.torrentPath,{path:n.path||n.downloadDirectory,store:FSChunkStore,storeCacheSlots:10,skipVerify:!0,maxWebConns:client.maxConns,announce:[...n.trackers||[],...WEBTORRENT_ANNOUCEMENT]})):n.isSeeding&&n.magnetURI&&!n.isUploadByFiles?(console.log("[seed] add torrent with magnetURI"),s=client.add(n.magnetURI,{path:n.path||n.downloadDirectory,store:FSChunkStore,storeCacheSlots:10,skipVerify:!0,maxWebConns:client.maxConns,announce:[...n.trackers||[],...WEBTORRENT_ANNOUCEMENT]}),s.upload=!0,s.isSeeding=!0):(console.log("[seed] Seed torrent with files"),s=client.seed(t,{...n,store:FSChunkStore,storeCacheSlots:10,skipVerify:!0,maxWebConns:client.maxConns,announce:[...WEBTORRENT_ANNOUCEMENT]}),s.isUploadByFiles=!0),info("seedTorrent",n,s,t),n.name&&(s.name=n.name),s.isAutoUpload=o,s.token=e,s.isSeeding=!0,s.upload=!0,s.paused=!1,s.file=t,s.createdTime=n.createdTime||Date.now(),addListeners(s,n,!0),n.infoHash&&s.once("infoHash",(()=>locked.delete(n.infoHash))),s.once("infoHash",(()=>{r&&r()})),s.once("metadata",(()=>{ipcRenderer.send("webtorrent-seed",torrentToJson(s))})),s},getTorrent=()=>{const e=client.torrents.map((e=>torrentToJson(e)));return info(e),ipcRenderer.send("webtorrent-list",e)},setThrottleGroup=({infoHash:e,peerId:t,subId:n,level:o})=>{const r=client.get(e);if(!r)return info("not found",e),ipcRenderer.send("webtorrent-set-throttle",{code:-1,message:"Torrent Not Found"}),null;let s=null,i=null;for(let a of r.wires)if(n?a.remoteSub===n:a.peerId===t){s=a;try{a._setThrottleGroup(o)}catch(d){i={code:-1,message:d.message}}break}return s?i?ipcRenderer.send("webtorrent-set-throttle",i):ipcRenderer.send("webtorrent-set-throttle",{code:0,message:"success"}):ipcRenderer.send("webtorrent-set-throttle",{code:-1,message:"Peer Not Found"}),s},saveTorrentFile=(e,t)=>{const n="webtorrent-save-torrent",o=client.get(e);if(!o)return;if(!o.torrentFile||!o.name)return ipcRenderer.send(n,{code:-1,message:"Torrent Not Ready"});const r=path.resolve(t,`${o.name}.torrent`);fs.writeFileSync(r,o.torrentFile),ipcRenderer.send(n,{code:0,message:"success",infoHash:e,torrentPath:r})};let server=null,serverInfoHash="";const startTorrentServer=e=>{if(info("Start server",e),server){if(serverInfoHash===e.infoHash)return ipcRenderer.send("webtorrent-server-ready",e.infoHash,{token:e.token,port:server.address().port});server.destroy(),server=null,serverInfoHash=""}info("Create server",e),server=e.createServer(),server.listen(0,(()=>{const t=server.address().port,n={token:e.token,port:t};ipcRenderer.send("webtorrent-server-ready",e.infoHash,n);const o=()=>{const t=e.files.map((t=>{let n=[];for(let o=t._startPiece;o<t._endPiece;o++)n.push(null===e.pieces[o]?1:0);return{name:t.name,path:t.path,progress:n}}));ipcRenderer.send("webtorrent-server-progress",e.infoHash,t)};setTimeout(o,1e3);const r=setInterval(o,5e3);server.once("close",(()=>clearInterval(r)))}))},startServer=(e,t)=>{info("start server",e,t);let n=client.get(e);if(!n)return addTorrent(t.token||t.infoHash,t,(()=>startServer(e,t)));n.ready?startTorrentServer(n,t):n.once("ready",(()=>startTorrentServer(n,t)))},stopServer=()=>{server&&(server.destroy(),server=null,serverInfoHash="",info("Destroy server"))};(function(){ipcRenderer.on("add-torrent",((e,t,n)=>addTorrent(t,n))),ipcRenderer.on("stop-torrent",((e,t)=>(info("got stop",t),stopTorrent(t)))),ipcRenderer.on("stop-all-uploading",((e,t)=>{t.forEach((e=>{const t=client.torrents.find((t=>!(!t.infoHash||t.infoHash!==e.infoHash)||!(!t.token||t.token!==e.token)));t&&t.destroy()}))})),ipcRenderer.on("delete-all",((e,t,n,o)=>{shouldSendInfo=!1,console.log("Delete all",t,n,o);const r=client.torrents.filter((e=>{if("all"===t)return!0;const n=e.upload||1===e.progress||e.isSeeding;return"upload"===t?!(!o&&e.isAutoUpload)&&n:!n}));if(!r.length)return void(shouldSendInfo=!0);let s=0;r.forEach((t=>{s++,console.log(t.infoHash),shouldDelete.push(t.infoHash),t.removeAllListeners();try{t.destroy({destroyStore:n},(()=>{shouldDelete.includes(t.infoHash)&&shouldDelete.splice(shouldDelete.indexOf(t.infoHash),1),s--,0===s&&(shouldSendInfo=!0)}))}catch(e){}})),setTimeout((()=>{shouldSendInfo=!0}),2e3)})),ipcRenderer.on("seed-torrent",((e,t)=>{let{file:n,token:o,...r}=t;return n||(n=t.files.map((e=>e.path))),info(t),n.length?(o||(o=Math.random().toString().substr(2)),seedTorrent(o,n,r)):ipcRenderer.send("seed-error")})),ipcRenderer.on("autoupload-files",(async(e,t)=>{info("autoupload files",t),Promise.all(t.map((e=>{if(info("Auto upload",e),!client.torrents.some((t=>t.files.some((t=>t.path===e))||t.file&&t.file.some&&t.file.some((t=>t===e))||t.file===e)))return new Promise((t=>{seedTorrent("autoupload-"+e,e,{},!0,t)}));info(`${e} is already uploaded, skipped`)}))).then((()=>{info("autoupload complete"),ipcRenderer.send("autoupload-complete")})).catch((e=>{ipcRenderer.send("autoupload-complete",e.message||e)}));let n=[];client.torrents.forEach((e=>{e.isAutoUpload&&e.ready&&(e.files.some((e=>t.includes(e.path)))?info(`${e.infoHash} is kept alive`):(info(`${e.infoHash} has been deleted. Destroy`,e.files.map((e=>e.path))),n.push(e)))})),n.forEach((e=>{e.destroy((()=>{ipcRenderer.send("webtorrent-delete",e.infoHash)}))}))})),ipcRenderer.on("start-server",((e,{infoHash:t,conf:n})=>startServer(t,n))),ipcRenderer.on("stop-server",(()=>stopServer())),ipcRenderer.on("delete-torrent",((e,t,n)=>deleteTorrent(t,n))),ipcRenderer.on("pend-torrent",((e,t)=>{const n=client.get(t.infoHash);infoHashes.includes(t.infoHash)&&infoHashes.splice(infoHashes.indexOf(t.infoHash),1),info("Pend",t.infoHash,n),n&&(n.removeAllListeners(),n.destroy(),n.pending=!0,ipcRenderer.send("webtorrent-pending",torrentToJson(n)))})),ipcRenderer.on("set-throttle-group",((e,{infoHash:t,peerId:n,subId:o,level:r})=>{info(t,n,o,r),setThrottleGroup({infoHash:t,peerId:n,subId:o,level:r})})),ipcRenderer.on("save-torrent-file",((e,t,n)=>saveTorrentFile(t,n))),ipcRenderer.on("update-settings",((e,{uploadSpeed:t,downloadSpeed:n,maximumConnectionsNum:o,DHTlistenPort:r,BTlistenPort:s,payedUserShareRate:i})=>{const d=parseInt(r),a=parseInt(s);if(info("Set client",{uploadSpeed:t,downloadSpeed:n,maximumConnectionsNum:o,dhtPort:d,torrentPort:a,payedUserShareRate:i}),i){const e=Number(i)||.7;localStorage.setItem("payedUserShareRate",e.toString())}if(t){const e=speedLimit(t);localStorage.setItem("uploadSpeed",e.toString())}const l=Number(localStorage.getItem("payedUserShareRate"))||.7,c=parseInt(localStorage.getItem("uploadSpeed"));if(isNaN(l)||isNaN(c)||(-1===c?client.throttleUpload(-1):client.throttleUpload(c,l)),n){const e=speedLimit(n);client.throttleDownload(e),localStorage.setItem("downloadSpeed",e.toString())}o&&(client.maxConns=o,localStorage.setItem("maximumConnectionsNum",o.toString()));let p=!1;d&&d!==parseInt(localStorage.getItem("dhtPort"))&&(p=!0,localStorage.setItem("dhtPort",d.toString())),a&&a!==parseInt(localStorage.getItem("torrentPort"))&&(p=!0,localStorage.setItem("torrentPort",a.toString())),p&&location.reload()})),ipcRenderer.on("reset-torrent",(()=>{info("reset"),shouldSendInfo=!1,Promise.all(client.torrents.map((e=>new Promise((t=>{e.removeAllListeners(),e.destroy({destroyStore:!0},t)}))))).then((()=>ipcRenderer.send("webtorrent-reset"))).catch((()=>ipcRenderer.send("webtorrent-reset-error"))).finally((()=>{info("resetted"),client.torrents.length=0,shouldSendInfo=!0}))})),initClient(0),window.addEventListener("error",(e=>(info(e.message||e),!0)))})();
const path=require("path"),{networkInterfaces:networkInterfaces}=require("os"),getPieceMap=e=>{if(!e.ready)return[];const r=e.pieces.length,t=r+128-r%128,a=t/128,o=[];let n=1,s=0;for(let d=0;d<t;d++)e.pieces[d]?n&=0:n&=1,s++,s>=a&&(o.push(n),n=1,s=0);return o};export const getByteMap=e=>{const r=getPieceMap(e),t=[];let a=0,o=0;for(let n=0;n<r.length;n++)o|=r[n]<<a,a++,a>=8&&(t.push(o),a=0,o=0);return t};const responseTorrentProps=["infoHash","name","paused","length","downloaded","uploaded","ready","waiting","progress","isSeeding","upload","token","completed","origin","path","pending","file","magnetURI","isAutoUpload","isUploadByFiles","createdTime","completedTime","usedTime"],torrentToJson=(e,r,t)=>{const a={};responseTorrentProps.forEach((r=>{a[r]=e[r]})),a.done=e.downloaded>=e.length,a.download=1!==e.progress&&!e.upload,a.upload=e.upload,a.recieved=e.received,a.files=e.files?e.files.map((r=>({name:r.name,path:path.resolve(e.path,r.path),progress:r.progress>0?r.progress:0}))).filter((e=>!e.name.match(/^_____padding_file_(.*)____$/))):[],e.timeRemaining&&(a.timeRemaining=e.timeRemaining),e.metadata&&(a.hasMetadata=!0),e.numPeers&&(a.peersNum=e.numPeers);const o=getByteMap(e);return e.byteMap&&!o.some(((r,t)=>e.byteMap[t]!==r))||(e.byteMap=o,console.log("change byteMap",o),e.emit("byte-map-change")),a.byteMap=e.byteMap,e.trackerMap?a.trackerList=[...e.trackerMap.values()]:a.trackerList=[],a.connections=e.wires.map((a=>{let o="low";a._uploadThrottle._group===client.throttleGroups.mid&&(o="mid"),a._uploadThrottle._group===client.throttleGroups.high&&(o="high");let n=0,s=0;if(t.has(a._debugId)){const e=t.get(a._debugId);n=(a.downloaded-e.downloaded)/r,s=(a.uploaded-e.uploaded)/r}t.set(a._debugId,{downloaded:a.downloaded,uploaded:a.uploaded});let d=!1;return e.byteMap&&a.remote_byte_map&&(d=e.byteMap.some(((e,r)=>{try{const t=e.toString(2).padStart(8,"0"),o=a.remote_byte_map[r].toString(2).padStart(8,"0");for(let e=0;e<t.length;e++)if("0"===t[e]&&"1"===o[e])return!0;return!1}catch(t){return!1}}))),{id:a.peerId,address:a.remoteAddress,isAbPeer:a._is_alphabiz_peer_,hasMeta:a.remote_has_meta,hasResource:d,remoteByteMap:a.remote_byte_map||[],uploadSpeed:s,downloadSpeed:n,user:a.remoteUser,subId:a.remoteSub,transactions:a.transactions,remoteGroup:a.remoteGroup,downloaded:a.downloaded,level:o}})),a.connections.sort(((e,r)=>e.address&&e.address.localeCompare?e.address.localeCompare(r.address):0)),a},getLocalIPList=()=>{const e=networkInterfaces(),r=new Set;for(const t in e){const a=e[t];a.forEach((e=>{r.add(e.address)}))}return[...r]},parseTrackerWarning=e=>"string"===typeof e&&e.includes("(")?e.substring(0,e.indexOf("(")).trim():e,addTracker=(e,r)=>{if(!e.discovery||!e.discovery.tracker)return;const t=e.discovery.tracker;if(!t._trackers.find((e=>e.announceUrl===r))&&t._createTracker)try{const e=t._createTracker(r);if(!e)return;t._trackers.push(e),e.setInterval(),e.announce(t._defaultAnnounceOpts())}catch(a){console.error("addTracker error",a)}},removeTracker=(e,r,t)=>{if(!e.discovery||!e.discovery.tracker)return t();const a=e.discovery.tracker._trackers,o=a.findIndex((e=>e.announceUrl===r));if(-1===o)return t();const n=a[o];n&&n.destroy?n.destroy(((...e)=>{const o=a.findIndex((e=>e.announceUrl===r));-1!==o&&a.splice(o,1),"function"===typeof t&&t(...e)})):t()};export default{torrentToJson:torrentToJson,getLocalIPList:getLocalIPList,getPieceMap:getPieceMap,parseTrackerWarning:parseTrackerWarning,addTracker:addTracker,removeTracker:removeTracker};
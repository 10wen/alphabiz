const path=require("path"),{networkInterfaces:networkInterfaces}=require("os"),responseTorrentProps=["infoHash","name","paused","length","downloaded","uploaded","ready","waiting","progress","isSeeding","upload","token","completed","origin","path","pending","file","magnetURI","isAutoUpload","createdTime","completedTime","usedTime"],torrentToJson=(e,o,d)=>{const t={};return responseTorrentProps.forEach((o=>{t[o]=e[o]})),t.done=e.downloaded>=e.length,t.download=1!==e.progress&&!e.upload,t.upload=e.upload,t.recieved=e.received,t.files=e.files?e.files.map((o=>({name:o.name,path:path.resolve(e.path,o.path),progress:o.progress>0?o.progress:0}))).filter((e=>!e.name.match(/^_____padding_file_(.*)____$/))):[],e.timeRemaining&&(t.timeRemaining=e.timeRemaining),e.metadata&&(t.hasMetadata=!0),e.numPeers&&(t.peersNum=e.numPeers),t.connections=[],e.wires.forEach((e=>{let r="low";e._uploadThrottle._group===client.throttleGroups.mid&&(r="mid"),e._uploadThrottle._group===client.throttleGroups.high&&(r="high");let a=0,s=0;if(d.has(e._debugId)){const t=d.get(e._debugId);a=(e.downloaded-t.downloaded)/o,s=(e.uploaded-t.uploaded)/o}d.set(e._debugId,{downloaded:e.downloaded,uploaded:e.uploaded}),t.connections.push({id:e.peerId,address:e.remoteAddress,isAbPeer:e._is_alphabiz_peer_,hasMeta:e.remote_has_meta,uploadSpeed:s,downloadSpeed:a,user:e.remoteUser,subId:e.remoteSub,transactions:e.transactions,remoteGroup:e.remoteGroup,downloaded:e.downloaded,level:r})})),t.connections.sort(((e,o)=>e.address&&e.address.localeCompare?e.address.localeCompare(o.address):0)),t},getLocalIPList=()=>{const e=networkInterfaces(),o=new Set;for(const d in e){const t=e[d];t.forEach((e=>{o.add(e.address)}))}return[...o]};export default{torrentToJson:torrentToJson,getLocalIPList:getLocalIPList};